"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[5940],{75940:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"error-kinds","title":"Error Kinds","description":"Pyrefly error categories and suppression codes","source":"@site/docs/error-kinds.mdx","sourceDirName":".","slug":"/error-kinds","permalink":"/en/docs/error-kinds","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/pyrefly/edit/main/website/docs/error-kinds.mdx","tags":[],"version":"current","frontMatter":{"title":"Error Kinds","description":"Pyrefly error categories and suppression codes"},"sidebar":"docsSidebar","previous":{"title":"Error Suppressions","permalink":"/en/docs/error-suppressions"},"next":{"title":"Import Resolution","permalink":"/en/docs/import-resolution"}}');var r=s(74848),a=s(28453);const t={title:"Error Kinds",description:"Pyrefly error categories and suppression codes"},o="Error Kinds",l={},d=[{value:"annotation-mismatch",id:"annotation-mismatch",level:2},{value:"assert-type",id:"assert-type",level:2},{value:"async-error",id:"async-error",level:2},{value:"bad-argument-count",id:"bad-argument-count",level:2},{value:"bad-argument-type",id:"bad-argument-type",level:2},{value:"bad-assignment",id:"bad-assignment",level:2},{value:"bad-class-definition",id:"bad-class-definition",level:2},{value:"bad-function-definition",id:"bad-function-definition",level:2},{value:"bad-keyword-argument",id:"bad-keyword-argument",level:2},{value:"bad-override",id:"bad-override",level:2},{value:"bad-return",id:"bad-return",level:2},{value:"bad-specialization",id:"bad-specialization",level:2},{value:"bad-unpacking",id:"bad-unpacking",level:2},{value:"delete-error",id:"delete-error",level:2},{value:"import-error",id:"import-error",level:2},{value:"index-error",id:"index-error",level:2},{value:"internal-error",id:"internal-error",level:2},{value:"invalid-annotation",id:"invalid-annotation",level:2},{value:"invalid-argument",id:"invalid-argument",level:2},{value:"invalid-inheritance",id:"invalid-inheritance",level:2},{value:"invalid-literal",id:"invalid-literal",level:2},{value:"invalid-overload",id:"invalid-overload",level:2},{value:"invalid-param-spec",id:"invalid-param-spec",level:2},{value:"invalid-super-call",id:"invalid-super-call",level:2},{value:"invalid-syntax",id:"invalid-syntax",level:2},{value:"invalid-type-var",id:"invalid-type-var",level:2},{value:"invalid-type-var-tuple",id:"invalid-type-var-tuple",level:2},{value:"invalid-yield",id:"invalid-yield",level:2},{value:"match-error",id:"match-error",level:2},{value:"missing-argument",id:"missing-argument",level:2},{value:"missing-attribute",id:"missing-attribute",level:2},{value:"missing-module-attribute",id:"missing-module-attribute",level:2},{value:"no-access",id:"no-access",level:2},{value:"no-matching-overload",id:"no-matching-overload",level:2},{value:"not-a-type",id:"not-a-type",level:2},{value:"not-callable",id:"not-callable",level:2},{value:"not-iterable",id:"not-iterable",level:2},{value:"parse-error",id:"parse-error",level:2},{value:"read-only",id:"read-only",level:2},{value:"reveal-type",id:"reveal-type",level:2},{value:"type-alias-error",id:"type-alias-error",level:2},{value:"typed-dict-key-error",id:"typed-dict-key-error",level:2},{value:"unbound-name",id:"unbound-name",level:2},{value:"unexpected-keyword",id:"unexpected-keyword",level:2},{value:"unknown-name",id:"unknown-name",level:2},{value:"unsupported-operand",id:"unsupported-operand",level:2},{value:"unsupported",id:"unsupported",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"error-kinds",children:"Error Kinds"})}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.em,{children:"error kind"})," categorizes an error by the part of the typing specification\nthat an error is related to. Every error has exactly one kind."]}),"\n",(0,r.jsx)(n.p,{children:'The main use of error kinds is as short names ("slugs") that can be used in\nerror suppression comments.'}),"\n",(0,r.jsx)(n.h2,{id:"annotation-mismatch",children:"annotation-mismatch"}),"\n",(0,r.jsx)(n.p,{children:"This error indicates a mismatch between multiple annotations for a single\nvariable. This is relatively uncommon, but it can happen in if-statements:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'if some_cond:\n    x: int = 1\nelse:\n    x: str = "two" # Inconsistent type annotations for x: str, int [annotation-mismatch]\n'})}),"\n",(0,r.jsx)(n.p,{children:"It can be helpful to annotate the variable before branch, especially if there is\na useful default value for it. For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'x: str = "default"\nif some_cond:\n  x = "actual value"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"assert-type",children:"assert-type"}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.code,{children:"assert-type"})," error is raised when a ",(0,r.jsx)(n.code,{children:"typing.assert_type()"})," call fails."]}),"\n",(0,r.jsxs)(n.p,{children:["This error kind should never be suppressed, since that rather defeats the point\nof of ",(0,r.jsx)(n.code,{children:"typing.assert_type()"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"async-error",children:"async-error"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"async-error"})," is reported when attempting to ",(0,r.jsx)(n.code,{children:"await"})," on something that is not\nawaitable. This may indicate that a function should have been marked ",(0,r.jsx)(n.code,{children:"async"})," but\nwasn't."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def some_func() -> None:\n  ...\n\nawait some_func() # Expression is not awaitable [async-error]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This will also arise if the context manager used in an ",(0,r.jsx)(n.code,{children:"async with"})," statement\nhas ",(0,r.jsx)(n.code,{children:"__aenter__"})," and ",(0,r.jsx)(n.code,{children:"__aexit__"})," methods that are not marked ",(0,r.jsx)(n.code,{children:"async"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The fix is to use an ",(0,r.jsx)(n.code,{children:"async"})," function in the ",(0,r.jsx)(n.code,{children:"await"}),". This may mean making the\nfunction ",(0,r.jsx)(n.code,{children:"async"})," or finding an existing ",(0,r.jsx)(n.code,{children:"async"})," function to use instead."]}),"\n",(0,r.jsx)(n.h2,{id:"bad-argument-count",children:"bad-argument-count"}),"\n",(0,r.jsx)(n.p,{children:"This error arises when a function is called with the wrong number of arguments."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def takes_three(one: int, two: int, three: int) -> complex:\n  ...\n\ntake_three(3, 2)  # Expected 1 more positional argument [bad-argument-count]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note that ",(0,r.jsx)(n.code,{children:"missing-argument"})," will be raised if pyrefly can identify that\nspecific arguments are missing. As such, this error is more likely to appear\nwhen too many args are supplied, rather than too few."]}),"\n",(0,r.jsx)(n.p,{children:"This example shows both kinds of errors:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from typing import Callable\ndef apply(f: Callable[[int, int], int]) -> int:\n    return f(1)  # Expected 1 more positional argument [bad-argument-count]\napply() # Missing argument `f` in function `apply` [missing-argument]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"bad-argument-type",children:"bad-argument-type"}),"\n",(0,r.jsx)(n.p,{children:"This error indicates that the function was called with an argument of the wrong\ntype."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def example(x: int) -> None:\n  ...\nexample(\"one\")  # Argument `Literal['two']` is not assignable to parameter `x` with type `int` in function `example` [bad-argument-type]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This can also happen with ",(0,r.jsx)(n.code,{children:"*args"})," and ",(0,r.jsx)(n.code,{children:"**kwargs"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def bad_args(*args: int) -> None:\n  ...\n\nbad_args(1, \"two\")  # Argument `Literal['two']` is not assignable to parameter with type `int` in function `bad_args` [bad-argument-type]\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def bad_kwargs(**kwargs: int) -> None:\n  ...\n\nbad_args(x=1, y=\"two\")  # Keyword argument `y` with type `Literal['two']` is not assignable to kwargs type `int` in function `bad_kwargs` [bad-argument-type]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"bad-assignment",children:"bad-assignment"}),"\n",(0,r.jsx)(n.p,{children:"The most common cause of this error is attempting to assign a value that conflicts with the variable's type annotation."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"x: str = 1 # `Literal[1]` is not assignable to `str` [bad-assignment]\n"})}),"\n",(0,r.jsx)(n.p,{children:"However, it can occur in several other situations."}),"\n",(0,r.jsxs)(n.p,{children:["Here, ",(0,r.jsx)(n.code,{children:"x"})," is marked as ",(0,r.jsx)(n.code,{children:"Final"}),", so assigning a new value to it is an error."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from typing import Final\nx: Final = 1\nx = 2 # `x` is marked final [bad-assignment]\n"})}),"\n",(0,r.jsx)(n.p,{children:"In another case, attempting to annotate an assignment to an instance attribute raises this error."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class A:\n    x: int\na = A()\na.x: int = 2  # Type cannot be declared in assignment to non-self attribute `a.x` [bad-assignment]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"bad-class-definition",children:"bad-class-definition"}),"\n",(0,r.jsxs)(n.p,{children:["This error indicates that there is something wrong with the class definition.\nIt tends to be a bit rarer, since most issues would be tagged with other error kinds, such as\n",(0,r.jsx)(n.code,{children:"annotation-mismatch"})," or one of the function errors.\ninheritance has its own complexities, so it has its own error kind called ",(0,r.jsx)(n.code,{children:"invalid-inheritance"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"One place you may see it is dynamic class generation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from enum import Enum\nEx = Enum("Ex", [("Red", 1), ("Blue", 2), ("Red", 3)])  # Duplicate field `Red` [bad-class-definition]\n'})}),"\n",(0,r.jsx)(n.p,{children:"However, it is best practice to use the class syntax if possible, which doesn't treat duplicate names as an error."}),"\n",(0,r.jsx)(n.h2,{id:"bad-function-definition",children:"bad-function-definition"}),"\n",(0,r.jsxs)(n.p,{children:["Like ",(0,r.jsx)(n.code,{children:"bad-class-definition"}),", this error kind is uncommon because other error kinds are used for more specific issues.\nFor example, argument order is enforced by the parser, so ",(0,r.jsx)(n.code,{children:"def f(x: int = 1, y: str)"})," is a ",(0,r.jsx)(n.code,{children:"parse-error"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"bad-keyword-argument",children:"bad-keyword-argument"}),"\n",(0,r.jsx)(n.p,{children:"bad-keyword-argument pops up when a keyword argument is given multiple values:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def f(x: int) -> None:\n  pass\nf(x=1, x=2)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["However, this is often accompanied by a ",(0,r.jsx)(n.code,{children:"parse-error"})," for the same issue."]}),"\n",(0,r.jsx)(n.h2,{id:"bad-override",children:"bad-override"}),"\n",(0,r.jsx)(n.p,{children:"When a subclass overrides a field or method of its base class, care must be taken that the override won't cause problems."}),"\n",(0,r.jsx)(n.p,{children:"Some of these are obvious:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Base:\n  def f(self, a: int) -> None:\n    pass\n\nclass NoArg(Base):\n  def f(self) -> None:\n    pass\n\nclass WrongType(Base):\n  def f(self, a: str) -> None:\n    pass\n\ndef uses_f(b: Base) -> None:\n  b.f(1)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["These errors are rather obvious: ",(0,r.jsx)(n.code,{children:"uses_f"})," will fail if given a ",(0,r.jsx)(n.code,{children:"NoArg"})," or ",(0,r.jsx)(n.code,{children:"WrongType"})," instance, because those methods don't expect an ",(0,r.jsx)(n.code,{children:"int"})," argument!"]}),"\n",(0,r.jsxs)(n.p,{children:["The guiding idea here is the ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Liskov_substitution_principle",children:"Liskov Substitution Principle"}),", the idea that a subclass can stand in for a base class at any point without breaking the program."]}),"\n",(0,r.jsx)(n.p,{children:"This can be a little subtle at first blush. Consider:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Base:\n  def f(self, a: int) -> None:\n    pass\n\nclass Sub(Base):\n  def f(self, a: float) -> None:\n    pass\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Is this OK? Yes! ",(0,r.jsx)(n.code,{children:"int"})," is treated as a subclass of ",(0,r.jsx)(n.code,{children:"float"}),", or to put it another way, a function that accepts ",(0,r.jsx)(n.code,{children:"float"})," can accept every ",(0,r.jsx)(n.code,{children:"int"}),".\nThat means everywhere that we call ",(0,r.jsx)(n.code,{children:"Base.f"})," can safely call ",(0,r.jsx)(n.code,{children:"Sub.f"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The opposite case, where ",(0,r.jsx)(n.code,{children:"Base.f"})," takes ",(0,r.jsx)(n.code,{children:"float"})," and ",(0,r.jsx)(n.code,{children:"Sub.f"})," takes ",(0,r.jsx)(n.code,{children:"int"}),", is an error because ",(0,r.jsx)(n.code,{children:"Sub.f"})," cannot accept every ",(0,r.jsx)(n.code,{children:"float"})," value."]}),"\n",(0,r.jsx)(n.h2,{id:"bad-return",children:"bad-return"}),"\n",(0,r.jsx)(n.p,{children:"Arises when a function does not return a value that is compatible with the function's return type annotation."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def bad_return() -> None:\n  return 1\n"})}),"\n",(0,r.jsx)(n.p,{children:"Real-world examples are often less obvious, of course, due to complex control flow and type relationships."}),"\n",(0,r.jsx)(n.p,{children:"This error is also raised for generator functions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from typing import Generator\n# Generator has 3 types: the yield, send, and return types.\ndef bad_gen() -> Generator[int, None, str]:\n  yield 1\n  return 2  # should be a str!\n"})}),"\n",(0,r.jsx)(n.h2,{id:"bad-specialization",children:"bad-specialization"}),"\n",(0,r.jsxs)(n.p,{children:['"Specialization" refers to instantiating a generic type with a concrete type.\nFor example, ',(0,r.jsx)(n.code,{children:"list"})," is a generic type, and ",(0,r.jsx)(n.code,{children:"list[int]"})," is that type specialized with ",(0,r.jsx)(n.code,{children:"int"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Each generic type has an expected number of type vars, and each type var can be bound or constrained.\nAttempting to use specialize a generic type in a way that violates these specifications will result in a ",(0,r.jsx)(n.code,{children:"bad-specialization"})," error:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"x: list[int, str]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"bad-unpacking",children:"bad-unpacking"}),"\n",(0,r.jsx)(n.p,{children:"An error caused by unpacking, such as attempting to unpack a list, tuple, or iterable into the wrong number of variables."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def two_elems() -> tuple[int, str]:\n  return (1, "two")\n\na, b, c = two_elems()\n'})}),"\n",(0,r.jsx)(n.p,{children:"Note that pyrefly can only report this error if it knows how many elements the thing being unpacked has."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# A bare `tuple` could have any number of elements\ndef two_elems() -> tuple:\n  return (1, "two")\n\na, b, c = two_elems()\n'})}),"\n",(0,r.jsx)(n.h2,{id:"delete-error",children:"delete-error"}),"\n",(0,r.jsxs)(n.p,{children:["This error occurs when attempting to ",(0,r.jsx)(n.code,{children:"del"})," something that cannot be deleted."]}),"\n",(0,r.jsxs)(n.p,{children:["Besides obvious things like built-in values (you can't ",(0,r.jsx)(n.code,{children:"del True"}),"!), some object attributes are protected from deletion.\nFor example, read-only and required ",(0,r.jsx)(n.code,{children:"TypedDict"})," fields cannot be deleted."]}),"\n",(0,r.jsx)(n.h2,{id:"import-error",children:"import-error"}),"\n",(0,r.jsx)(n.p,{children:"An error related to the import mechanism, such as when a module cannot be found."}),"\n",(0,r.jsxs)(n.p,{children:["The error message will include which paths were searched, such as the site package paths.\nYou may be missing a dependency, or you may need to inform Pyrefly where the module lives. See ",(0,r.jsx)(n.a,{href:"/en/docs/configuration",children:"Configuration"})," for further information."]}),"\n",(0,r.jsx)(n.h2,{id:"index-error",children:"index-error"}),"\n",(0,r.jsx)(n.p,{children:"Attempting to access a container with an incorrect index.\nThis only occurs when Pyrefly can statically verify that the index is incorrect, such as with a fixed-length tuple."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def add_three(x: tuple[int, int]) -> int:\n  return x[0] + x[1] + x[2]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Pyrefly also knows the keys of ",(0,r.jsx)(n.code,{children:"TypedDict"}),"s, but those have their own error kind."]}),"\n",(0,r.jsx)(n.h2,{id:"internal-error",children:"internal-error"}),"\n",(0,r.jsxs)(n.p,{children:["Ideally you'll never see this one. If you do, please consider ",(0,r.jsx)(n.a,{href:"https://github.com/facebook/pyrefly/issues",children:"filing a bug"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"invalid-annotation",children:"invalid-annotation"}),"\n",(0,r.jsxs)(n.p,{children:["There are several reasons why an annotation may be invalid. The most common case is misusing a typing special form, such as ",(0,r.jsx)(n.code,{children:"typing.Final"}),", ",(0,r.jsx)(n.code,{children:"typing.ClassVar"}),", ",(0,r.jsx)(n.code,{children:"typing.ParamSpec"}),", and so on."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from typing import *\n\n# Final must have a value\na: Final\n# ClassVar can only be used in a class body\nb: ClassVar[int] = 1\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The error messages will explain how the special form is being misused. Consult the ",(0,r.jsx)(n.a,{href:"https://docs.python.org/3/library/typing.html",children:"typing docs"})," and ",(0,r.jsx)(n.a,{href:"https://typing.python.org/en/latest/spec/",children:"typing spec"})," for more information."]}),"\n",(0,r.jsx)(n.h2,{id:"invalid-argument",children:"invalid-argument"}),"\n",(0,r.jsx)(n.p,{children:"This error is used to indicate an issue with an argument to special typing-related functions."}),"\n",(0,r.jsxs)(n.p,{children:["For example, ",(0,r.jsx)(n.code,{children:"typing.NewType"})," is a handy special form for creating types that are distinct from a base type."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from typing import *\n\n# The first arg must match the name!\nMismatch = NewType("Wrong Name", int)\n\n# NewTypes cannot be used in isinstance.\nUserId = NewType("UserId", int)\nif isinstance(1, UserId):\n  ...\n'})}),"\n",(0,r.jsx)(n.h2,{id:"invalid-inheritance",children:"invalid-inheritance"}),"\n",(0,r.jsx)(n.p,{children:"An error caused by incorrect inheritance in a class or type definition.\nThis can pop up in quite a few cases:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Trying to subclass something that isn't a class."}),"\n",(0,r.jsxs)(n.li,{children:["Subclassing a type that does not support it, such as a ",(0,r.jsx)(n.code,{children:"NewType"})," or a ",(0,r.jsx)(n.code,{children:"Final"})," class."]}),"\n",(0,r.jsxs)(n.li,{children:["Attempting to mix ",(0,r.jsx)(n.code,{children:"Protocol"}),"s with non-",(0,r.jsx)(n.code,{children:"Protocol"})," base classes."]}),"\n",(0,r.jsx)(n.li,{children:"Trying to make a generic enum."}),"\n",(0,r.jsxs)(n.li,{children:["Trying to give a ",(0,r.jsx)(n.code,{children:"TypedDict"})," a metaclass."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"And so on!"}),"\n",(0,r.jsx)(n.h2,{id:"invalid-literal",children:"invalid-literal"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"typing.Literal"})," only allows a ",(0,r.jsx)(n.a,{href:"https://typing.python.org/en/latest/spec/literal.html#legal-parameters-for-literal-at-type-check-time",children:"limited set"})," of types as parameters.\nAttempting to use ",(0,r.jsx)(n.code,{children:"Literal"})," with anything else is an error."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from typing import Literal\n\n# These are legal\nLiteral[1.0]\nLiteral['a', 'b', 'c']\n# This is not\nclass A:\n  ...\nLiteral[A()]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"invalid-overload",children:"invalid-overload"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"@overload"})," decorator requires that the decorated function has at least two overloaded signatures and a base implementation."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from typing import *\n\n@overload\ndef no_base(x: int) -> None:\n  pass\n\n@overload\ndef no_base(x: str) -> int:\n  pass\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@overload\ndef just_one(x: int) -> None:\n  pass\n\ndef just_one(x: str) -> None:\n  ...\n"})}),"\n",(0,r.jsx)(n.h2,{id:"invalid-param-spec",children:"invalid-param-spec"}),"\n",(0,r.jsxs)(n.p,{children:["This error is reported when ",(0,r.jsx)(n.code,{children:"typing.ParamSpec"})," is defined incorrectly or misused. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from typing import *\n\nP = ParamSpec("Name Must Match!")\n\nP1 = ParamSpec("P1")\nP2 = ParamSpec("P2")\n\ndef f(x, *args: P1.args, **kwargs: P2.kwargs) -> None:\n  pass\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Here, ",(0,r.jsx)(n.code,{children:"P1.args"})," and ",(0,r.jsx)(n.code,{children:"P2.kwargs"})," can't be used together; ",(0,r.jsx)(n.code,{children:"*args"})," and ",(0,r.jsx)(n.code,{children:"**kwargs"})," must come from the same ",(0,r.jsx)(n.code,{children:"ParamSpec"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"invalid-super-call",children:"invalid-super-call"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"super()"})," has ",(0,r.jsx)(n.a,{href:"https://docs.python.org/3/library/functions.html#super",children:"a few restrictions"})," on how it is called."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"super()"})," can be called without arguments, but only when used inside a method of a class:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Legal(Base1, Base2):\n  def f(self) -> None:\n    super().f()\n\ndef illegal(arg: SomeType) -> None:\n  super().f()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When the function is called with two arguments, like ",(0,r.jsx)(n.code,{children:"super(T, x)"}),", then ",(0,r.jsx)(n.code,{children:"T"})," must be a type, and the second argument is either an object where ",(0,r.jsx)(n.code,{children:"isinstance(x, T)"})," is true\nor a type where ",(0,r.jsx)(n.code,{children:"issubclass(x, T)"})," is true."]}),"\n",(0,r.jsx)(n.h2,{id:"invalid-syntax",children:"invalid-syntax"}),"\n",(0,r.jsx)(n.p,{children:"This error covers syntactical edge cases that are not flagged by the parser."}),"\n",(0,r.jsx)(n.p,{children:"For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"x: list[int] = [0, 2, 3]\nx[0]: int = 1\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It's not a parse error for an assignment to have an annotation, but it is forbidden by the type checker to annotate assignment to a subscript like ",(0,r.jsx)(n.code,{children:"x[0]"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"invalid-type-var",children:"invalid-type-var"}),"\n",(0,r.jsx)(n.p,{children:"An error caused by incorrect usage or definition of a TypeVar. A few examples:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from typing import TypeVar\n# Old-style TypeVars must be assigned to a matching variable.\nWrong = TypeVar("Name")\n\n# PEP 695-style TypeVars can be constrained, but there must be at least two:\ndef only_one_constriant[T: (int,)](x: T) -> T:\n  ...\n\n# It\'s also illegal to mix the two styles together.\nT = TypeVar("T")\ndef mixed[S](a: S, b: T) -> None:\n  ...\n'})}),"\n",(0,r.jsx)(n.h2,{id:"invalid-type-var-tuple",children:"invalid-type-var-tuple"}),"\n",(0,r.jsx)(n.p,{children:"An error caused by incorrect usage or definition of a TypeVarTuple."}),"\n",(0,r.jsxs)(n.p,{children:["TypeVarTuple has similar error cases to ",(0,r.jsx)(n.a,{href:"#invalid-type-var",children:"TypeVar"}),", but also a few of its own. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from typing import TypeVarTuple\n\nTs = TypeVarTuple("Ts")\n\n# TypeVarTuples must always be unpacked:\nbad: tuple[Ts] = (...)\ngood: tuple[*Ts] = (...)\n\n# Only one TypeVarTuple is allowed in a list of type arguments:\ndef two_tups[*Xs, *Ys](xs: tuple[*Xs], ys: tuple[*Ys]) -> None:\n  ...\n'})}),"\n",(0,r.jsx)(n.h2,{id:"invalid-yield",children:"invalid-yield"}),"\n",(0,r.jsxs)(n.p,{children:["This error arises when ",(0,r.jsx)(n.code,{children:"yield"})," is used in a way that is not allowed. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from typing import Generator\n\nfor _ in range(1, 10):\n  yield "can\'t yield outside of a function!"\n\ndef bad_yield_from() -> Generator[int, None, None]:\n  # `yield from` can only be used with iterables.\n  yield from 1\n'})}),"\n",(0,r.jsx)(n.h2,{id:"match-error",children:"match-error"}),"\n",(0,r.jsx)(n.p,{children:"This error is used in two cases."}),"\n",(0,r.jsxs)(n.p,{children:["The first is when there is an issue with a ",(0,r.jsx)(n.code,{children:"match"})," statement. For example, ",(0,r.jsx)(n.code,{children:"Ex"})," only has 2 fields but the ",(0,r.jsx)(n.code,{children:"case"})," lists 3:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Ex:\n  __match_args__ = ('a', 'b')\n  def __init__(self, a: int, b: str) -> None:\n    self.a = a\n    self.b = b\n\ndef do(x: Ex) -> None:\n  match x:\n    case Ex(a, b, c):\n      print(\"This is an error\")\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It is also used when ",(0,r.jsx)(n.code,{children:"__match_args__"})," is defined incorrectly. It must be a tuple of the names of the class's attributes as literal strings.\nFor class ",(0,r.jsx)(n.code,{children:"Ex"})," in the previous example, ",(0,r.jsx)(n.code,{children:"__match_args__ = ('a', 'c')"})," would be an error because ",(0,r.jsx)(n.code,{children:"Ex.c"})," does not exist."]}),"\n",(0,r.jsx)(n.h2,{id:"missing-argument",children:"missing-argument"}),"\n",(0,r.jsx)(n.p,{children:"An error caused by calling a function without all the required arguments."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def takes_two(x: int, y: int) -> int:\n  return x + y\n\ntakes_two(1)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"missing-attribute",children:"missing-attribute"}),"\n",(0,r.jsx)(n.p,{children:"This error is raised when attempting to access an attribute that does not exist on the given object or module."}),"\n",(0,r.jsxs)(n.p,{children:["In the case of modules, attempting to import an nonexistent name will raise ",(0,r.jsx)(n.a,{href:"#missing-module-attribute",children:"`missing-module-attribute"})," instead."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import os\nfrom os import bacarat  # missing-module-attribute\nos.jongleur()  # missing-attribute\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note that objects with type ",(0,r.jsx)(n.code,{children:"Any"})," will never raise this error."]}),"\n",(0,r.jsx)(n.h2,{id:"missing-module-attribute",children:"missing-module-attribute"}),"\n",(0,r.jsx)(n.p,{children:"Arises when attempting to import a name that does not exist from a module."}),"\n",(0,r.jsxs)(n.p,{children:["This is distinct from ",(0,r.jsx)(n.a,{href:"#import-error",children:(0,r.jsx)(n.code,{children:"import-error"})}),", which is used when the module being imported does not exist, and ",(0,r.jsx)(n.a,{href:"#missing-attribute",children:(0,r.jsx)(n.code,{children:"missing-attribute"})}),", when access attributes of the module."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import this_does_not_exist  # import-error\nimport os.bacarat  # import-error\nfrom os import joker  # missing-module-attribute\nos.perkeo  # missing-attribute\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this example, ",(0,r.jsx)(n.code,{children:"os.bacarat"})," is treated as a module name, so failing to find it results in an ",(0,r.jsx)(n.code,{children:"import-error"}),".\n",(0,r.jsx)(n.code,{children:"from os import joker"})," does not tell us if ",(0,r.jsx)(n.code,{children:"joker"})," is a module, class, function, etc., so it is treated as the more general ",(0,r.jsx)(n.code,{children:"missing-module-attribute"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"no-access",children:"no-access"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"no-access"})," error indicates that an attribute exists, but it cannot be used in this way."]}),"\n",(0,r.jsx)(n.p,{children:"For example, classes do not have access to their instances' attributes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Ex:\n  def __init__(self) -> None:\n    self.meaning: int = 42\n\ndel Ex.meaning  # no-access\n"})}),"\n",(0,r.jsx)(n.h2,{id:"no-matching-overload",children:"no-matching-overload"}),"\n",(0,r.jsxs)(n.p,{children:["This error is similar to the other bad function call errors, but specifically for cases where a function decorated with ",(0,r.jsx)(n.code,{children:"@overload"})," is called with arguments that do not match any of the overloaded variations."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, neither of the signatures of ",(0,r.jsx)(n.code,{children:"f"})," can take an argument of type ",(0,r.jsx)(n.code,{children:"float"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from typing import overload\n\n@overload\ndef f(x: int) -> int:\n    ...\n\n@overload\ndef f(x: str) -> str:\n    ...\n\ndef f(x: int | str) -> int | str:\n    return x\n\nf(1.0)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"not-a-type",children:"not-a-type"}),"\n",(0,r.jsx)(n.p,{children:"This indicates an attempt to use something that isn't a type where a type is expected.\nIn most cases, a more specific error kind is used."}),"\n",(0,r.jsx)(n.p,{children:"You may see this error around incorrect type aliases:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class A:\n  ...\n# Not an alias, just a string!\nX = "A"\nx: X = ...  # X is not a type alias, so this is illegal\n'})}),"\n",(0,r.jsx)(n.h2,{id:"not-callable",children:"not-callable"}),"\n",(0,r.jsx)(n.p,{children:"A straightforward error: something that is not a function was used as if it were a function."}),"\n",(0,r.jsx)(n.p,{children:"One interesting place this error may occur is with decorators:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"x = 1\n\n@x  # not-callable\ndef foo() -> None:\n  ...\n"})}),"\n",(0,r.jsx)(n.h2,{id:"not-iterable",children:"not-iterable"}),"\n",(0,r.jsxs)(n.p,{children:["This is most likely to be seen in a ",(0,r.jsx)(n.code,{children:"for"})," loop:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"x = 1  # Or some other value\nfor val in x:  # not-iterable\n  ...\n"})}),"\n",(0,r.jsx)(n.h2,{id:"parse-error",children:"parse-error"}),"\n",(0,r.jsx)(n.p,{children:"An error related to parsing or syntax. This covers a variety of cases, such as function calls with duplicate keyword args, some poorly defined functions, and so on."}),"\n",(0,r.jsx)(n.h2,{id:"read-only",children:"read-only"}),"\n",(0,r.jsx)(n.p,{children:"This error indicates that the attribute being accessed does exist but cannot be modified."}),"\n",(0,r.jsxs)(n.p,{children:["For example, a ",(0,r.jsx)(n.code,{children:"@property"})," with no setter cannot be assigned to:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Ex:\n    @property\n    def meaning(self) -> int:\n        return 42\n\nx = Ex()\nx.meaning = 0\n"})}),"\n",(0,r.jsx)(n.h2,{id:"reveal-type",children:"reveal-type"}),"\n",(0,r.jsxs)(n.p,{children:["Pyrefly uses this error to communicate the output of the ",(0,r.jsx)(n.a,{href:"https://typing.python.org/en/latest/spec/directives.html#reveal-type",children:(0,r.jsx)(n.code,{children:"reveal_type"})})," function."]}),"\n",(0,r.jsx)(n.h2,{id:"type-alias-error",children:"type-alias-error"}),"\n",(0,r.jsxs)(n.p,{children:["An error related to the definition or usage of a ",(0,r.jsx)(n.code,{children:"typing.TypeAlias"}),". Many of these cases are covered by ",(0,r.jsx)(n.a,{href:"#invalid-annotation",children:(0,r.jsx)(n.code,{children:"invalid-annotation"})}),", so this error\nspecifically handles illegal type alias values:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from typing import TypeAlias\nx = 2\nBad: TypeAlias = x\n"})}),"\n",(0,r.jsx)(n.h2,{id:"typed-dict-key-error",children:"typed-dict-key-error"}),"\n",(0,r.jsxs)(n.p,{children:["This error arises when ",(0,r.jsx)(n.code,{children:"TypedDict"}),"s are used with incorrect keys, such as a key that does not exist in the ",(0,r.jsx)(n.code,{children:"TypedDict"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from typing import TypedDict\n\nclass Ex(TypedDict):\n    a: int\n    b: str\n\ndef test(x: Ex) -> None:\n    # These two keys don\'t exist\n    x.nope\n    x["wrong"]\n    # TypedDict keys must be strings!\n    x[1]\n'})}),"\n",(0,r.jsx)(n.h2,{id:"unbound-name",children:"unbound-name"}),"\n",(0,r.jsxs)(n.p,{children:["This error corresponds to the runtime ",(0,r.jsx)(n.code,{children:"NameError"}),", indicating that a variable is referenced but does not exist."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def do_things(stuff: list[int]) -> str:\n  ...\n\ndo_thing([1, 2])  # typo! Or, unbound-name\n"})}),"\n",(0,r.jsx)(n.h2,{id:"unexpected-keyword",children:"unexpected-keyword"}),"\n",(0,r.jsx)(n.p,{children:"A function was called with an extra keyword argument."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def two_args(a: int, b: int) -> int:\n  ...\n\ntwo_args(a=1, b=2, c=3)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"unknown-name",children:"unknown-name"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"unknown-name"})," occurs when attempting to load a name from another scope, but the name cannot be found."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def where() -> None:\n  # There is no spoon: unknown-name\n  global spoon\n"})}),"\n",(0,r.jsx)(n.h2,{id:"unsupported-operand",children:"unsupported-operand"}),"\n",(0,r.jsxs)(n.p,{children:["This error arises when attempting to perform an operation between values of two incompatible types.\nSince many Python operators are actually syntactic sugar for function calls, many operations will result in ",(0,r.jsx)(n.a,{href:"#bad-argument-type",children:(0,r.jsx)(n.code,{children:"bad-argument-type"})})," errors."]}),"\n",(0,r.jsxs)(n.p,{children:["An exception is the ",(0,r.jsx)(n.code,{children:"in"})," operator, which fails when looking for a value in something that does not support ",(0,r.jsx)(n.code,{children:"in"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'if "hello" in 1:  # int doesn\'t support `in`!\n  ...\n'})}),"\n",(0,r.jsx)(n.h2,{id:"unsupported",children:"unsupported"}),"\n",(0,r.jsx)(n.p,{children:"This error indicates that pyrefly does not currently support a typing feature."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);