"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[5839],{65839:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"import-resolution","title":"Import Resolution","description":"How Pyrefly finds and resolves imports","source":"@site/docs/import-resolution.mdx","sourceDirName":".","slug":"/import-resolution","permalink":"/en/docs/import-resolution","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/pyrefly/edit/main/website/docs/import-resolution.mdx","tags":[],"version":"current","frontMatter":{"title":"Import Resolution","slug":"/import-resolution","description":"How Pyrefly finds and resolves imports"},"sidebar":"docsSidebar","previous":{"title":"Error Kinds","permalink":"/en/docs/error-kinds"}}');var s=n(74848),o=n(28453);const r={title:"Import Resolution",slug:"/import-resolution",description:"How Pyrefly finds and resolves imports"},a="Import Resolution",c={},l=[{value:"Relative Imports",id:"relative-imports",level:2},{value:"Absolute Imports",id:"absolute-imports",level:2},{value:"Implicit Search Path",id:"implicit-search-path",level:3},{value:"Site Package Path Typing Rules",id:"site-package-path-typing-rules",level:3},{value:"Stub Files vs Source Files",id:"stub-files-vs-source-files",level:2},{value:"Debugging Import Issues",id:"debugging-import-issues",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"import-resolution",children:"Import Resolution"})}),"\n",(0,s.jsx)(i.p,{children:"This doc describes how imports in a given file are found and their bindings are\nresolved, including files that are being type checked."}),"\n",(0,s.jsx)(i.p,{children:"NOTE: This document helps describe the internal behavior of Pyrefly and how we attempt to resolve imports. You should not need to know how this works, to use Pyrefly but may assist in debugging issues with Pyrefly not finding your imports. If you encounter a bug, please leave an issue for us on GitHub."}),"\n",(0,s.jsxs)(i.p,{children:["NOTE: see the ",(0,s.jsx)(i.a,{href:"/en/docs/configuration",children:"Configuration documentation"})," for more info on\nthe config items referenced below."]}),"\n",(0,s.jsx)(i.h2,{id:"relative-imports",children:"Relative Imports"}),"\n",(0,s.jsxs)(i.p,{children:["If the import is relative (starting with one or more dots), the import is\nresolved relative to the path of the file importing it. A single dot at the\nbeginning of the import (e.g. ",(0,s.jsx)(i.code,{children:".file.to.import"}),") represents the current\ndirectory, and more dots (e.g. ",(0,s.jsx)(i.code,{children:"..other.file"}),") will continue to walk upward."]}),"\n",(0,s.jsx)(i.h2,{id:"absolute-imports",children:"Absolute Imports"}),"\n",(0,s.jsx)(i.p,{children:"For absolute imports, Pyrefly uses the following import strategy:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["Try to import from each entry in ",(0,s.jsx)(i.a,{href:"/en/docs/configuration#search_path",children:(0,s.jsx)(i.code,{children:"search_path"})})," in the order they appear\nusing the module finding strategy."]}),"\n",(0,s.jsxs)(i.li,{children:["Try to import from ",(0,s.jsx)(i.code,{children:"typeshed"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:["Try to import implicit site packages. See the ",(0,s.jsx)(i.a,{href:"#implicit-search-path",children:"implicit site packages section"})]}),"\n",(0,s.jsxs)(i.li,{children:["Try to find a stub package corresponding to the import we're trying to resolve in\n",(0,s.jsx)(i.a,{href:"/en/docs/configuration#site_package_path",children:(0,s.jsx)(i.code,{children:"site_package_path"})}),".\nEntries earlier in the ",(0,s.jsx)(i.code,{children:"site_package_path"})," list will be selected before those appearing later in the list."]}),"\n",(0,s.jsxs)(i.li,{children:["Try to find a non-stub package corresponding to the import we're trying to resolve in ",(0,s.jsx)(i.code,{children:"site_package_path"}),".\nEntries earlier in the ",(0,s.jsx)(i.code,{children:"site_package_path"})," list will be selected before those appearing later in the list."]}),"\n",(0,s.jsx)(i.li,{children:"Return an import error."}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["See ",(0,s.jsx)(i.a,{href:"#site-package-path-typing-rules",children:"Site Package Path Typing Rules"})," for more information about which\nmodules are valid imports from ",(0,s.jsx)(i.a,{href:"/en/docs/configuration#site_package_path",children:(0,s.jsx)(i.code,{children:"site_package_path"})}),", and\nhow to override that behavior."]}),"\n",(0,s.jsx)(i.h3,{id:"implicit-search-path",children:"Implicit Search Path"}),"\n",(0,s.jsx)(i.p,{children:"Pyrefly will use the following heuristics to guess\nthe root of your project."}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["If we can find a Pyrefly config file using\n",(0,s.jsx)(i.a,{href:"/en/docs/configuration#configuration-finding",children:"configuration finding logic"}),", we will automatically\nuse that. When a configuration\nis found, we will add either a subdirectory named ",(0,s.jsx)(i.code,{children:"src/"}),", or the found root as a\n",(0,s.jsx)(i.a,{href:"/en/docs/configuration#search_path",children:(0,s.jsx)(i.code,{children:"search_path"})})," entry."]}),"\n",(0,s.jsxs)(i.li,{children:["If we're looking for a specific import and can match components of its specific name\nwith directories/files on the filesystem, we will use the root of the import as the\nproject root. Example: when importing ",(0,s.jsx)(i.code,{children:"from a.b.c import q"}),", if our project structure\nlooks like ",(0,s.jsx)(i.code,{children:"/x/y/z/a/b/c"}),", we can walk up the components of ",(0,s.jsx)(i.code,{children:"a.b.c"})," to find a root at\n",(0,s.jsx)(i.code,{children:"/x/y/z"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:["If the file we're importing is a non-namespace import, and we can't get it's parent\ndirectory, return a basic-default config with no heuristics. For example:","\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"# Assume we have a file called mymodule.py in the same directory\nimport mymodule\n"})}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["Finally, with either the non-namespace import's parent directory or namespace import's\nimmediate directory, walk up the filesystem and add each directory we find until\nroot to the ",(0,s.jsx)(i.code,{children:"fallback_search_path"}),"."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"site-package-path-typing-rules",children:"Site Package Path Typing Rules"}),"\n",(0,s.jsxs)(i.p,{children:["When enabled with ",(0,s.jsx)(i.a,{href:"/en/docs/configuration#use_untyped_imports",children:(0,s.jsx)(i.code,{children:"use_untyped_imports: false"})}),", we respect\ntyping rules as defined by the typing spec for\n",(0,s.jsx)(i.a,{href:"https://typing.python.org/en/latest/spec/distributing.html#stub-only-packages",children:"stubs packages"}),",\n",(0,s.jsx)(i.a,{href:"https://typing.python.org/en/latest/spec/distributing.html#partial-stub-packages",children:"partial stubs packages"}),",\nand ",(0,s.jsx)(i.a,{href:"https://typing.python.org/en/latest/spec/distributing.html#packaging-type-information",children:"py.typed"})," files.\nThat means:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["if we can find any ",(0,s.jsx)(i.code,{children:"-stubs"})," package, we do not fall back to non-stubs packages unless any of them contain a\n",(0,s.jsx)(i.code,{children:"py.typed"})," file in their top-level containing the content ",(0,s.jsx)(i.code,{children:"partial\\n"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:["if we can't find any ",(0,s.jsx)(i.code,{children:"-stubs"})," packages, only accept a package's types if it contains a ",(0,s.jsx)(i.code,{children:"py.typed"})," file. Here,\nwe only check for the existence of the file, not for any contents."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"You can control the above behavior with the following two configs:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"/en/docs/configuration#use_untyped_imports",children:(0,s.jsx)(i.code,{children:"use_untyped_imports"})}),": don't worry about looking for any ",(0,s.jsx)(i.code,{children:"py.typed"}),"\nfile. Check for ",(0,s.jsx)(i.code,{children:"-stubs"})," first and fall back to non-stubs, regardless of the presence of a ",(0,s.jsx)(i.code,{children:"py.typed"})," with\n",(0,s.jsx)(i.code,{children:"partial\\n"})," or if the non-stubs packages contain a ",(0,s.jsx)(i.code,{children:"py.typed"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"/en/docs/configuration#ignore_missing_source",children:(0,s.jsx)(i.code,{children:"ignore_missing_source"})}),": don't try to check for a backing non-stubs\npackage when we find a ",(0,s.jsx)(i.code,{children:"-stubs"})," package. Immediately return the ",(0,s.jsx)(i.code,{children:"-stubs"})," package when found."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"stub-files-vs-source-files",children:"Stub Files vs Source Files"}),"\n",(0,s.jsxs)(i.p,{children:["A\n",(0,s.jsx)(i.a,{href:"https://typing.python.org/en/latest/spec/distributing.html#stub-files",children:"stub file"}),"\nis any file that ends with a ",(0,s.jsx)(i.code,{children:".pyi"})," file suffix. They have many uses, including\nadding typing to non-Python extension code, distributing typing information\nseparate from implementation, or overriding an implementation with more accurate\ntyping information."]}),"\n",(0,s.jsxs)(i.p,{children:["A stub package is a second package corresponding to a regular package, with ",(0,s.jsx)(i.code,{children:"-stubs"}),"\nappended to its name. A ",(0,s.jsx)(i.code,{children:"-stubs"})," package should only include stub files (",(0,s.jsx)(i.code,{children:".pyi"}),"),\nwhich override any ",(0,s.jsx)(i.code,{children:".py"})," or ",(0,s.jsx)(i.code,{children:".pyi"})," files in the non-stubs package. These are preferred\nwhen available, since they contain the interfaces a library exposes to developers. An\nexample of this includes the popular library ",(0,s.jsx)(i.a,{href:"https://github.com/pandas-dev/pandas",children:(0,s.jsx)(i.code,{children:"pandas"})}),",\nand its stub package, ",(0,s.jsx)(i.a,{href:"https://github.com/pandas-dev/pandas-stubs",children:(0,s.jsx)(i.code,{children:"pandas-stubs"})}),"."]}),"\n",(0,s.jsxs)(i.p,{children:["When importing from a non-stubs package, Pyrefly loads typing information from\nimports by first searching for a relevant ",(0,s.jsx)(i.code,{children:"-stubs"})," package, then by looking at\nthe non-stubs package's ",(0,s.jsx)(i.code,{children:".pyi"})," files, then falls back to a ",(0,s.jsx)(i.code,{children:".py"})," file. See\n",(0,s.jsx)(i.a,{href:"#absolute-imports",children:"Absolute Imports"})," for details on when non-stubs packages\nare allowed to be used for types, and how you can override that behavior."]}),"\n",(0,s.jsx)(i.h2,{id:"debugging-import-issues",children:"Debugging Import Issues"}),"\n",(0,s.jsxs)(i.p,{children:["Pyrefly has a ",(0,s.jsx)(i.code,{children:"dump-config"})," command that dumps the import-related config options it is using for\neach file it is checking. To use it, simply replace ",(0,s.jsx)(i.code,{children:"check"})," with ",(0,s.jsx)(i.code,{children:"dump-config"})," in your\ncommand-line invocation."]})]})}function h(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);