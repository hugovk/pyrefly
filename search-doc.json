[{"title":"Introduction","type":0,"sectionRef":"#","url":"/en/docs/","content":"","keywords":"","version":"Next"},{"title":"Benefits of Type Checking​","type":1,"pageTitle":"Introduction","url":"/en/docs/#benefits-of-type-checking","content":" Adding type annotations to your Python code and using a type checker like Pyrefly provides several important benefits:  Catch bugs early - Identify type-related errors during development rather than at runtimeImprove code quality - Type annotations serve as living documentation, making your code more readable and self-documentingEnhance developer experience - Get better IDE support with accurate autocomplete, refactoring tools, and inline documentationSafer refactoring - Make large-scale changes with confidence, knowing the type checker will catch incompatible type usageBetter collaboration - Types create clear contracts between different parts of your codebase, making it easier for teams to work together  ","version":"Next","tagName":"h2"},{"title":"Try Pyrefly​","type":1,"pageTitle":"Introduction","url":"/en/docs/#try-pyrefly","content":" Here's a simple example showing how Pyrefly can catch type errors:  # Example: Basic Type Checking def greet(name: str) -&gt; str: return &quot;Hello, &quot; + name # This works fine since both &quot;World&quot; is a string and greet expects a string message = greet(&quot;World&quot;) # Pyrefly catches this error before runtime due to a type misatch between 42 and &quot;str&quot; # Error: Argument of type 'int' is not assignable to parameter of type 'str' error_message = greet(42)  In this example, Pyrefly flags the second call to greet() because we're passing an integer (42) where a string is expected, helping you catch this issue before your code runs. To learn more about Python typing and how to use it effectively:  If you're new to Python, check out our Python Typing for Beginners guide.If you're familiar with Python but new to typing, see our Typing for Python Developers guide. ","version":"Next","tagName":"h2"},{"title":"Pyrefly Configuration","type":0,"sectionRef":"#","url":"/en/docs/configuration/","content":"","keywords":"","version":"Next"},{"title":"Precedence in Options​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#precedence-in-options","content":" The following is the order in which configuration options are selected:  CLI flagEnvironment variable override -- This is the same as PYREFLY_&lt;CLI flag name&gt;Configuration optionHard-coded default  ","version":"Next","tagName":"h2"},{"title":"Type Checking Modes​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#type-checking-modes","content":" Pyrefly has two different modes it can run in when type checking your project, which correspond to different but useful ways we expect most people to interact with Pyrefly:  Project mode: attempt to load a config, falling back to Pyrefly's default config when none can be found, and type check using that one config. This involves getting theproject_includes and project_excludes from the file, expanding the patterns, and type checking on those files. Project mode is used whenever no files are provided with the CLI invocation. Per-file or Single-file mode: when given FILES... (and optionally --project-excludes) during a CLI invocation, expand the patterns and find the relevant config file for each file listed. project_includes and project_excludes are ignored from the config file, but it is used for all remaining config options.  ","version":"Next","tagName":"h2"},{"title":"Configuration Finding​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-finding","content":" In both project checking mode and single-file checking mode (see Type Checking Modesfor more info), we attempt to find a project root from which to check each file, both for reading config options and for import resolution (see Import Root). The project root is typically the directory containing the configuration file. More precisely:  If a configuration file is provided with -c/--config, we use its containing directory.Otherwise, we perform an upward file search from the 'start location' to the filesystem root, looking in each directory for any of the following files: pyrefly.toml, pyproject.toml,setup.py, mypy.ini, and pyrightconfig.json. If we find one, we use the current directory.  Note that only pyrefly.toml and pyproject.toml are parsed for config options, but we look for additional files that mark the root of a project to aid import resolution.  For project checking mode, the 'start location' is current working directory. For single-file checking mode, the start location is the directory containing each file to be type checked, and we find the config for each file matched by the pattern provided.  If a pyrefly.toml is found, it is parsed and used for type checking, and will return an error to the user on invalid types, syntax, values, or unknown config options.  If a pyproject.toml is found, Pyrefly will use the [tool.pyrefly]section if it exists, otherwise it will assume a default config. The same errors will be returned as when loading a pyrefly.toml if the config is invalid.  ","version":"Next","tagName":"h2"},{"title":"Providing a Config in Single-File Mode​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#providing-a-config-in-single-file-mode","content":" Providing -c/--config in single-file checking mode disables the upward file search for config files. All options are read from the provided config file except project_includes andproject_excludes, which are ignored.  ","version":"Next","tagName":"h3"},{"title":"Configuration Options​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-options","content":" The following section lists all recognized options that can be specified in a config file or pyproject.toml Pyrefly config section.  ","version":"Next","tagName":"h2"},{"title":"project_includes​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#project_includes","content":" The glob patterns used to describe which files to type check, typically understood as user-space files.  This does not specifyImport Resolution priority or the path an import should be resolved from. See search_path instead.  Type: list of filesystem glob patternsDefault: [&quot;**/*.py&quot;, &quot;**/*.pyi&quot;]Flag equivalent: FILES... argumentEquivalent configs: include in Pyright, files/modules/packages in mypyNotes: When overridden by passing in FILES..., we do not consult the relevant config file for what to use for project_excludes. Ifproject_excludes should not use the default value, override it with the flag as well.When a project_includes pattern does not match any files, we will return an error.If you get an error about no matches for a directory when passing a glob as a CLI argument, try wrapping the glob in quotes to prevent eager shell glob expansion.  ","version":"Next","tagName":"h3"},{"title":"project_excludes​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#project_excludes","content":" The glob patterns used to describe which files to avoid type checking as way to filter files that match project_includes, but we don't want to type check.  Type: list of filesystem glob patternsDefault: [&quot;**/.[!/.]*&quot;]Flag equivalent: --project-excludesEquivalent configs: exclude in Pyright and mypyNotes: It is an error if no files are returned from any project_includes because they are filtered out by project_excludes entries. We differentiate between an error from a project_includes that doesn't match any files, and an error from all project_includes getting filtered by project_excludes.When passing in FILES..., we also do not consult the config file for what to use for project_excludes. If project_excludes should not use the default value, override it with a flag as well. When no FILES... are passed,project_excludes overrides the config's value.  ","version":"Next","tagName":"h3"},{"title":"search_path​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#search_path","content":" A file path describing the roots from which imports should be found and imported from (including modules in project_includes). This takes the highest precedence in import order, before typeshed and site_package_path. When a project_includestype checked file is imported by another type checked file, we check all search roots to determine how to import it.  Type: list of directories specifying the rootDefault: import rootFlag equivalent: --search-pathENV equivalent: PYREFLY_SEARCH_PATHEquivalent configs: extraPaths in Pyright, mypy_path in mypyNotes: We automatically append an import root (typically the directory containing the configuration file) to the search_roots when type checking as a sensible default and last attempt at an import.Libraries should not be listed here, since they may override typeshedvalues for your whole project, and have different import semantics with respect to typing. SeeImport Resolutionfor more information about how modules are imported.  ","version":"Next","tagName":"h3"},{"title":"site_package_path​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#site_package_path","content":" A file path describing a root from which imports should be found and imported from. This takes the lowest priority in import resolution, after search_path and typeshed.  site_package_path entries have special rules around when they can be imported, according to the typing specification. SeeSite Package Path Typing Rulesfor more information, and use_untyped_imports andignore_missing_source for details on how to configure that behavior.  Type: list of directoriesDefault: result from Environment Autoconfiguration, or[] if the Python interpreter cannot be queriedFlag equivalent: --site-package-pathENV equivalent: PYREFLY_SITE_PACKAGE_PATHEquivalent configs: none  NOTE: Ideally, this should not be set manually, unless you're using a venv, running one-off tests, testing specific behavior, or having trouble with Environment Autoconfiguration. Setting this explicitly, especially when not using a venv, will make it difficult for your configuration to be reused between different systems and platforms.  ","version":"Next","tagName":"h3"},{"title":"python_platform​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#python_platform","content":" The value used with conditions based on type checking againstsys.platformvalues.  Type: stringDefault: result from Environment Autoconfiguration, or &quot;linux&quot; if the Python interpreter cannot be queriedFlag equivalent: --python-platformENV equivalent: PYREFLY_PYTHON_PLATFORMEquivalent configs: pythonPlatform in Pyright, platform in mypy  ","version":"Next","tagName":"h3"},{"title":"python_version​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#python_version","content":" The value used with conditions based on type checking againstsys.versionvalues. The format should be &lt;major&gt;[.&lt;minor&gt;[.&lt;micro&gt;]], where minor and micro can be omitted to take the default positional value.  Type: string of the format &lt;major&gt;[.&lt;minor&gt;[.&lt;micro&gt;]]Default: result from Environment Autoconfiguration, or3.13.0 if the Python interpreter cannot be queriedFlag equivalent: --python-versionENV equivalent: PYREFLY_PYTHON_VERSIONEquivalent configs: pythonVersion in Pyright, python_version in mypy  ","version":"Next","tagName":"h3"},{"title":"python_interpreter​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#python_interpreter","content":" The Python interpreter to query when attempting to autoconfigure Python environment values (site_package_path, python_platform, python_version). See the Environment Autoconfiguration section for more information.  Type: path to executableDefault: $(which python3), then $(which python), or noneFlag equivalent: --python-interpreterENV equivalent: PYREFLY_PYTHON_INTERPRETEREquivalent configs: python_executable in mypyNotes: This executes the value present in the python_interpreter field without any checks. It could be a security risk if your python_interpreter is an arbitrary executable.  NOTE: Ideally, this should not be set manually, unless you're using a venv, running one-off tests, testing specific behavior, or having trouble with Environment Autoconfiguration. Setting this explicitly, especially when not using a venv, will make it difficult for your configuration to be reused between different systems and platforms.  ","version":"Next","tagName":"h3"},{"title":"errors​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#errors","content":" Configure (enable and disable) the errors Pyrefly emits. true (default) tells Pyrefly to emit the error, while false tells Pyrefly to hide it.  Type: Table of error code to boolean representing enabled statusDefault: errors = {}/[errors]Flag equivalent: noneENV equivalent: noneEquivalent configs:type check rule overridesand type evaluation settingsin Pyright,enable_error_code anddisable_error_codein mypyNotes: setting &lt;error-code&gt; = true is the same as having no error code configuration present, which means the error will be shown. Setting &lt;error-code&gt; = false will disable the error for type checking.  ","version":"Next","tagName":"h3"},{"title":"replace_imports_with_any​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#replace_imports_with_any","content":" ModuleGlobs of modules from which import errors should be ignored, and the module should be replaced with typing.Any. For example, withfrom x.y import z in a file, adding x.*, *.y, or x.y to this config will silence those import errors and replace the module with typing.Any. If the module can be found, its type information will still be replaced with typing.Any.  Type: list of regexDefault: []Flag equivalent: noneENV equivalent: noneEquivalent configs: ignore_missing_imports or follow_imports = skip in mypyNotes: errors = {import-error = false} (TOML inline table for errors) has similar behavior in Pyrefly, but ignoresall import errors instead of import errors from specific modules, and won't replace findable modules with typing.Any.  ","version":"Next","tagName":"h3"},{"title":"ignore_errors_in_generated_code​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#ignore_errors_in_generated_code","content":" Whether to ignore type errors in generated code. If enabled, generated files will be treated as if they are included in project_excludes. The generated code status is determined by checking if the file contents contain the substring '@generated'.  Type: boolDefault: falseFlag equivalent: --ignore-errors-in-generated-codeENV equivalent: IGNORE_ERRORS_IN_GENERATED_CODEEquivalent configs: none  ","version":"Next","tagName":"h3"},{"title":"use_untyped_imports​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#use_untyped_imports","content":" Whether to search imports in site_package_path that do not have apy.typed file unconditionally. When this is true, we skip any checks for py.typed files, and return the first valid import we can find. SeeSite Package Path Typing Rules for more information on when a site_package_path cannot be used for typing information.  Type: boolDefault: trueFlag equivalent: noneENV equivalent: noneEquivalent configs: useLibraryCodeForTypes in Pyright, follow_untyped_imports in mypy  ","version":"Next","tagName":"h3"},{"title":"ignore_missing_source​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#ignore_missing_source","content":" Whether to skip the check for a non-stubs package when a -stubs package is found insite_package_path. When this is true, we immediately return a -stubs package when found.  The check for a non-stubs package exists to ensure you have an importable package to use in your project. When this check returns an import error, it means we couldn't find a package, and that at runtime you may not actually be able to import the given package, even if its type stubs could be found. SeeStub Files vs Source Files for more information.  Type: boolDefault: trueFlag equivalent: noneENV equivalent: noneEquivalent configs: reportMissingModuleSource in Pyright  ","version":"Next","tagName":"h3"},{"title":"untyped_def_behavior​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#untyped_def_behavior","content":" How should Pyrefly treat function definitions with no parameter or return type annotations?  By default, Pyrefly uses the &quot;check-and-infer-return-type&quot; behavior and will check all function bodies inferring the return type.  If this option is set to &quot;check-and-infer-return-any&quot;, then Pyrefly will still check the function body but will treat the return type as Any.  If this option is set to &quot;skip-and-infer-return-any&quot;, Pyrefly will again treat the return type as Any, but will also skip checking the function body. In this case, Pyrefly will also infer Any as the type of any attributes inferred based on this function body. This behavior is what PEP 484 specifies, although we do not recommend it for most users today; since Pyrefly will not analyze the bodies of untyped functions, language server functionality like showing types on hover and finding definitions will not be available there.  Type: one of &quot;check-and-infer-return-type&quot;, &quot;check-and-infer-return-any&quot;,&quot;skip-and-infer-return-any&quot;Default: `&quot;check-and-infer-return-type&quot;Flag equivalent: noneENV equivalent: noneEquivalent configs: The &quot;check-and-infer-return-type&quot; behavior emulates Pyright's default behavior.The &quot;skip-and-infer-return-any&quot; behavior emulates mypy's default behavior.The &quot;check-and-infer-return-any&quot; behavior emulates mypy'scheck_untyped_defs flag.  ","version":"Next","tagName":"h3"},{"title":"sub_config​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#sub_config","content":" Override specific config values for matched paths in your project. SeeSubConfigs for more information on the structure and values that can be overridden here.  Type: TOML array of tables with a SubConfig structureDefault: []Flag equivalent: noneENV equivalent: noneEquivalent configs: executionEnvironments in Pyright, per-module config options in mypy  ","version":"Next","tagName":"h3"},{"title":"Configuration Details​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-details","content":" This section describes some of the configuration options, behaviors, or types in more depth, when there are details shared between multiple config options or the information is more than what can fit under a single config option description.  ","version":"Next","tagName":"h2"},{"title":"Environment Autoconfiguration​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#environment-autoconfiguration","content":" If any of python_platform, python_version, orsite_package_path are empty, we attempt to query an interpreter for the missing values. By default we query $(which python3) or $(which python) if they're available on the path, but the interpreter can be overridden with the python_interpreter config option and flag. If the interpreter does not exist, we fall back to Pyrefly's defaults for all unspecified values.  The values queried from the interpreter are:  python_platform: sys.platformpython_version: sys.version_info[:3]site_package_path: site.getsitepackages() + [site.getusersitepackages()]  ","version":"Next","tagName":"h3"},{"title":"Filesystem Globbing​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#filesystem-globbing","content":" We use a standard Unix-style glob, which allows for wildcard matching when specifying a fileset. It is similar to regex, but more restricted given the subset of allowed syntax for paths on a filesystem. We currently only allow matching files with a .py or .pyi suffix.  The globs provided are relative to the config, if one is found, or the current working directory otherwise. Absolute path globs can also be provided, though this is generally not recommended, since it may not be compatible with other systems type checking your project.  We recognize the following wildcards: *, which matches zero or more characters in a single directory component**, which matches the current and any sub directories/files in those sub directories?, which matches any one character[&lt;pattern&gt;], which matches any character or character range between the brackets (character range separated by -)[!&lt;pattern&gt;], which excludes any character or character range between the brackets and after the ![] can be used to match ?, *, [, ] literally (e.g. [?]), although these are invalid as part of a Python path.  We also support non-wildcard paths, so a relative (or absolute) path like src/ will match all Python files under src/or src/my_file.py will match src/my_file.py exactly.  Any directories matched will also have their .py and .pyi files recursively matched. src/* will match all files and directories under src/, so therefore, we will recursively match everything under src/.  Examples:  src/**/*.py: only match .py files under src/src, src/, src/*, src/**, and src/**/*: match all .py and .pyi files under `src/?.py and [A-z].py: match any file that looks like &lt;letter&gt;.pysrc/path/to/my/file.py: only match src/path/to/my/file.pysrc/**/tests, src/**/tests/, src/**/tests/**, and src/**/tests/**/*: match all .py and .pyi files in src/under a directory named tests  ","version":"Next","tagName":"h3"},{"title":"Module Globbing​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#module-globbing","content":" In some config options, we've added globbing for module paths. This is different from both path globs and regex, in the sense that we're performing a match on a Python dotted import, such as this.is.any.module. The only wildcard we recognize is *, which represents zero or more segments of a module path, unless it starts a glob, in which case it must match one or more segments. The wildcard must be surrounded by ., unless it is at the start or end of a module glob.  Examples:  this.is.a.module would be equivalent to a regex like ^this\\.is\\.a\\.module. It will only match imports that look likethis.is.a.module.this.is.*.module would become ^this\\.is(\\..+)*\\.module$. It would match: this.is.modulethis.is.a.modulethis.is.a.really.long.path.to.a.module *.my.module would be equivalent to a regex like ^.+\\.my\\.module$. It would match: this.is.my.moduleheres.my.module It will not match: my.module this.is.* would be equivalent to a regex like ^this\\.is(\\..+)*. It would match: this.is.my.modulethis.is  ","version":"Next","tagName":"h3"},{"title":"SubConfigs​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#subconfigs","content":" SubConfigs are a method for overriding one or more config options for specific files based on filepath glob matching. Only certain config options are allowed to be overridden, and a need to override other configs means you likely need to use a separate config file for your subdirectory. You can have as many SubConfigs as you want in a project, and even multiple separate SubConfigsthat can apply to a given file when the matches glob pattern matches.  SubConfig Allowed Overrides​  We currently allow the following config options to be overridden in a SubConfig:  errorsreplace_imports_with_anyuntyped_def_behaviorignore_errors_in_generated_code  All SubConfig overrides replace the values appearing in the 'root' or top-level of the Pyrefly configuration.  Any configs that change the list of files we're type checking, Python environment, or where we look for imports cannot be included in SubConfigs. Some other configs we also do not include because we think they make it difficult to reason about your project type checks, but you canopen an issue or make a pull request if you disagree and would like to see the option supported.  SubConfig Table Structure​  A SubConfig has two or more entries:  a matches key, with a Filesystem Glob detailing which files the config applies to.at least one of the SubConfig allowed overrides  SubConfig Option Selection​  Since you can have more than one SubConfig matching a file, we need to define a resolution order to determine which SubConfig's option should be selected. Pyrefly does this by filteringSubConfigs whose matches does not match the given file, then takes the first non-null value that can be found in the order the SubConfigs appear in your configuration.  If no SubConfigs match, or there are no non-null config options present, then we take the value in the 'root'/top-level Pyrefly config (or Pyrefly default if no value is specified).  ","version":"Next","tagName":"h3"},{"title":"Conda and Venv Support​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#conda-and-venv-support","content":" We plan on adding extra automatic support for Condaand Venv at some point soon, but we haven't made it around to doing this yet. If you would like to import packages from these in the meantime, you can follow the following steps.  ","version":"Next","tagName":"h3"},{"title":"Venv​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#venv","content":" If you have a venv set up locally, you can get Pyrefly working with it by having your venv sourced in your shell (source .venv/bin/activate), and we will automatically pick up your installed packages. To pick up your packages even when your environment isn't sourced, you can add .venv/bin/python3 (or&lt;path_to_venv&gt;/bin/python3) to your Pyrefly configuration underpython_interpreter or pass it in with the --python-interpreter flag.  ","version":"Next","tagName":"h3"},{"title":"Conda​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#conda","content":" If you have conda set up locally, you can get Pyrefly working with it by having your Conda environment sourced in your shell (conda activate &lt;environment&gt;), and we will automatically pick up your installed packages. To pick up your packages even when your environment isn't sourced, you can query your environment's install location with conda env list, and add &lt;conda_environment_path&gt;/bin/python3 to your Pyrefly configuration under python_interpreter or pass it in with the --python-interpreter flag.  ","version":"Next","tagName":"h3"},{"title":"Example Configuration​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#example-configuration","content":" This section displays an example config showing the usage of all config options listed above to make creating your own easier, and to give you an easy place to start.  ","version":"Next","tagName":"h2"},{"title":"Default pyrefly.toml​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#default-pyreflytoml","content":" This is a configuration with the Pyrefly defaults. If you have an interpreter installed, some of these values may be overridden.  ###### configuring what to type check and where to import from # check all files in &quot;.&quot; project_includes = [&quot;.&quot;] # exclude dotfiles project_excludes = [&quot;**/.[!/.]*&quot;] # import project files from &quot;.&quot; search_path = [&quot;.&quot;] # do not include any third-party packages site_package_path = [] ###### configuring your python environment # assume we're running on linux, regardless of the actual current platform python_platform = &quot;linux&quot; # assume the Python version we're using is 3.13, without querying an interpreter python_version = &quot;3.13&quot; # query the default Python interpreter on your system, if installed and `python_platform`, # `python_version`, or `site_package_path` are unset. # python_interpreter = null # this is commented out because there are no `null` values in TOML #### configuring your type check settings replace_imports_with_any = [] ignore_errors_in_generated_code = false use_untyped_imports = false ignore_missing_source = false [errors] # this is an empty table, meaning all errors are enabled by default # no `[[sub_config]]` entries are included, since there are none by default   ","version":"Next","tagName":"h3"},{"title":"Example pyrefly.toml​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#example-pyreflytoml","content":" project_includes = [&quot;src&quot;] project_excludes = [&quot;**/.[!/.]*&quot;, &quot;**/tests&quot;] search_path = [&quot;src&quot;] site_package_path = [&quot;venv/lib/python3.12/site-packages&quot;] python_platform = &quot;linux&quot; python_version = &quot;3.12&quot; python_interpreter = &quot;venv/bin/python3&quot; replace_imports_with_any = [ &quot;sympy.*&quot;, &quot;*.series&quot;, ] ignore_errors_in_generated_code = true use_untyped_imports = true ignore_missing_source = true # disable `bad-assignment` and `invalid-argument` for the whole project [errors] bad-assignment = false invalid-argument = false [[sub_config]] # apply this to `sub/project/tests/file.py` matches = &quot;sub/project/tests/file.py&quot; # any unittest imports will by typed as `typing.Any` replace_imports_with_any = [&quot;unittest.*&quot;] [[sub_config]] # apply this config to all files in `sub/project` matches = &quot;sub/project/**&quot; # enable `assert-type` errors in `sub/project` [sub_config.errors] assert-type = true [[sub_config]] # apply this config to all files in `sub` matches = &quot;sub/**` # disable `assert-type` errors in `sub` [sub_config.errors] assert-type = false [[sub_config]] # apply this config to all files under `tests` dirs in `sub/` matches = &quot;sub/**/tests/**&quot; # any pytest imports will be typed as `typing.Any` replace_imports_with_any = [&quot;pytest.*&quot;]   With the above config, here are the actual config values some files would use:  sub/project/tests/file.py replace_imports_with_any: [&quot;unittest.*&quot;]errors: {assert-type = true}ignore_errors_in_generated_code: trueuse_untyped_imports: true sub/project/tests/another_file.py replace_imports_with_any: [&quot;pytest.*&quot;]errors: {assert-type = true}ignore_errors_in_generated_code: trueuse_untyped_imports: true sub/project/non_test_file.py replace_imports_with_any: [&quot;sympy.*&quot;, &quot;*.series&quot;]errors: {assert-type = true}ignore_errors_in_generated_code: trueuse_untyped_imports: true sub/sub_file.py replace_imports_with_any: [&quot;sympy.*&quot;, &quot;*.series&quot;]errors: {assert-type = false}ignore_errors_in_generated_code: trueuse_untyped_imports: true top_level_file.py replace_imports_with_any: [&quot;sympy.*&quot;, &quot;*.series&quot;]errors: {assert-type = true, bad-assignment = false, invalid-argument = false}ignore_errors_in_generated_code: trueuse_untyped_imports: true  ","version":"Next","tagName":"h3"},{"title":"Example pyproject.toml​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#example-pyprojecttoml","content":" ... # Pyrefly header [tool.pyrefly] #### configuring what to type check and where to import from project_includes = [&quot;src&quot;] project_excludes = [&quot;**/.[!/.]*&quot;, &quot;**/tests&quot;] search_path = [&quot;src&quot;] site_package_path = [&quot;venv/lib/python3.12/site-packages&quot;] #### configuring your python environment python_platform = &quot;linux&quot; python_version = &quot;3.12&quot; python_interpreter = &quot;venv/bin/python3&quot; #### configuring your type check settings replace_imports_with_any = [ &quot;sympy.*&quot;, &quot;*.series&quot;, ] ignore_errors_in_generated_code = true use_untyped_imports = true ignore_missing_source = true [tool.pyrefly.errors] bad-assignment = false invalid-argument = false [[tool.pyrefly.sub_config]] # apply this config to all files in `sub/project` matches = &quot;sub/project/**&quot; # enable `assert-type` errors in `sub/project` [tool.pyrefly.sub_config.errors] assert-type = true [[tool.pyrefly.sub_config]] # apply this config to all files in `sub` matches = &quot;sub/**` # disable `assert-type` errors in `sub/project` [tool.pyrefly.sub_config.errors] assert-type = false # other non-Pyrefly configs ...  ","version":"Next","tagName":"h3"},{"title":"Error Suppressions","type":0,"sectionRef":"#","url":"/en/docs/error-suppressions/","content":"","keywords":"","version":"Next"},{"title":"Upgrading Pyrefly (And other changes that introduce new type errors)​","type":1,"pageTitle":"Error Suppressions","url":"/en/docs/error-suppressions/#upgrading-pyrefly-and-other-changes-that-introduce-new-type-errors","content":" Upgrading the version of Pyrefly you're using, or a third party library you depend on can surface new type errors in your code. Fixing them all at once is often not realistic. We've written scripts to help you temporarily silence them.  # step 1 pyrefly check --suppress-errors   # step 2 &lt;run your formatter of choice&gt;   # step 3 pyrefly check --remove-unused-ignores   Repeat the steps above until you get a clean fomatting run and a clean type check.  This will add # pyrefly: ignore comments to your code that will enable you to silence errors, and come back and fix them at a later date. This can make the process of upgrading a large codebase much more manageable. ","version":"Next","tagName":"h2"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/en/docs/getting-started/","content":"Getting Started Pyrefly isn't ready just yet, but you can see our roadmap here. We will be populating this section soon!","keywords":"","version":"Next"},{"title":"Import Resolution","type":0,"sectionRef":"#","url":"/en/docs/import-resolution/","content":"","keywords":"","version":"Next"},{"title":"Relative Imports​","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#relative-imports","content":" If the import is relative (starting with one or more dots), the import is resolved relative to the path of the file importing it. A single dot at the beginning of the import (e.g. .file.to.import) represents the current directory, and more dots (e.g. ..other.file) will continue to walk upward.  ","version":"Next","tagName":"h2"},{"title":"Absolute Imports​","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#absolute-imports","content":" For absolute imports, Pyrefly uses the following import strategy:  Try to import from each entry in search_path in the order they appear using the module finding strategy. a. NOTE: we append an import root to search_pathautomatically when using a config file as a sensible last-resort for attempting an import.Try to import from typeshed.Try to find a stub package corresponding to the import we're trying to resolve insite_package_path. Entries earlier in the site_package_path list will be selected before those appearing later in the list. See the typing spec for more info on stub packages. If we find a -stubs package, but there's no non-stubs package, return an import error. Try to find a non-stub package corresponding to the import we're trying to resolve in site_package_path. Entries earlier in the site_package_path list will be selected before those appearing later in the list.Return an import error.  See Site Package Path Typing Rules for more information about which modules are valid imports from site_package_path, and how to override that behavior.  ","version":"Next","tagName":"h2"},{"title":"Import Root​","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#import-root","content":" Pyrefly automatically appends an import root to the search path. This is the directory that importable Python packages live in, determined from theproject root and layout. Pyrefly auto-detects import roots for two common project layouts:  Src layout, assumed when there is a src/ directory directly inside the project root. src/ is the import root.Flat layout, the default. The project root is the import root.  ","version":"Next","tagName":"h3"},{"title":"Site Package Path Typing Rules​","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#site-package-path-typing-rules","content":" We respect typing rules as defined by the typing spec forstubs packages,partial stubs packages, and py.typed files. That means:  if we can find any -stubs package, we do not fall back to non-stubs packages unless any of them contain apy.typed file in their top-level containing the content partial\\n.if we can't find any -stubs packages, only accept a package's types if it contains a py.typed file. Here, we only check for the existence of the file, not for any contents.  You can control the above behavior with the following two configs:  use_untyped_imports: don't worry about looking for any py.typedfile. Check for -stubs first and fall back to non-stubs, regardless of the presence of a py.typed withpartial\\n or if the non-stubs packages contain a py.typed.ignore_missing_source: don't try to check for a backing non-stubs package when we find a -stubs package. Immediately return the -stubs package when found.  ","version":"Next","tagName":"h3"},{"title":"Stub Files vs Source Files​","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#stub-files-vs-source-files","content":" Astub fileis any file that ends with a .pyi file suffix. They have many uses, including adding typing to non-Python extension code, distributing typing information separate from implementation, or overriding an implementation with more accurate typing information.  A stub package is a second package corresponding to a regular package, with -stubsappended to its name. A -stubs package should only include stub files (.pyi), which override any .py or .pyi files in the non-stubs package. These are preferred when available, since they contain the interfaces a library exposes to developers. An example of this includes the popular library pandas, and its stub package, pandas-stubs.  When importing from a non-stubs package, Pyrefly loads typing information from imports by first searching for a relevant -stubs package, then by looking at the non-stubs package's .pyi files, then falls back to a .py file. SeeAbsolute Imports for details on when non-stubs packages are allowed to be used for types, and how you can override that behavior.  ","version":"Next","tagName":"h2"},{"title":"Debugging Import Issues​","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#debugging-import-issues","content":" Pyrefly has a dump-config command that dumps the import-related config options it is using for each file it is checking. To use it, simply replace check with dump-config in your command-line invocation. ","version":"Next","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/en/docs/installation/","content":"","keywords":"","version":"Next"},{"title":"Upgrading Pyrefly​","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#upgrading-pyrefly","content":" Upgrading the version of Pyrefly you're using, or a third party library you depend on can surface new type errors in your code. Fixing them all at once is often not realistic. We've written scripts to help you temporarily silence them.  # step 1 pyrefly check --suppress-errors   # step 2 &lt;run your formatter of choice&gt;   # step 3 pyrefly check --remove-unused-ignores   Repeat the steps above until you get a clean formatting run and a clean type check.  ","version":"Next","tagName":"h2"},{"title":"This will add  # pyrefly: ignore comments to your code that will enable you to silence errors, and come back and fix them at a later date. This can make the process of upgrading a large codebase much more manageable.​","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#this-will-add---pyrefly-ignore-comments-to-your-code-that-will-enable-you-to-silence-errors-and-come-back-and-fix-them-at-a-later-date-this-can-make-the-process-of-upgrading-a-large-codebase-much-more-manageable","content":" ","version":"Next","tagName":"h2"},{"title":"Add Pyrefly to CI​","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#add-pyrefly-to-ci","content":" Once your project passes type checks without errors, you can ensure no new bugs are introduced. This is best enforced through CI (Continuous Integration) to prevent other maintainers from merging code with errors. Here is an example for GitHub.  Save your workflow in this path in your repository:  .github/workflows/typecheck.yml   GitHub automatically detects any .yml files inside .github/workflows/ and sets up the defined workflows.  name: Pyrefly Type Check on: pull_request: branches: [main] workflow_dispatch: # Allows manual triggering from the GitHub UI jobs: typecheck: runs-on: ubuntu-latest steps: - name: Check out code uses: actions/checkout@v4 - name: Set up Python uses: actions/setup-python@v5 # Install Python dependencies and create environment - name: Install dependencies and run type checking run: | python -m venv .venv source .venv/bin/activate python -m pip install --upgrade pip # Install your dependencies; adjust the following lines as needed pip install -r requirements-dev.txt - name: Install Pyrefly run: pip install pyrefly - name: Run Pyrefly Type Checker run: pyrefly check   ","version":"Next","tagName":"h2"},{"title":"A few notes about this setup:​","type":1,"pageTitle":"Installation","url":"/en/docs/installation/#a-few-notes-about-this-setup","content":" Building your environment and installing dependencies will enhance type safety by checking the types of imports. This is not required, but encouraged!Simply drop in pyrefly check to existing workflows that build and test your environment.   - name: Run Pyrefly Type Checker run: pyrefly check   Your pyrefly.toml or pyrefly configs in your pyproject.toml will be automatically detected. Learn how to configure pyrefly here. ","version":"Next","tagName":"h3"},{"title":"Pyrefly in the IDE","type":0,"sectionRef":"#","url":"/en/docs/IDE/","content":"","keywords":"","version":"Next"},{"title":"Quick start​","type":1,"pageTitle":"Pyrefly in the IDE","url":"/en/docs/IDE/#quick-start","content":" Install the Pyrefly extension from the VSCode marketplace or OpenVSXOpen a python file and the extension will activate  ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"Pyrefly in the IDE","url":"/en/docs/IDE/#features","content":" The Pyrefly extension provides:  Inline type errors matching the Pyrefly command-lineTypes shown inline and on hoverGo-to definitionAutocomplete / intellisenseBasic document symbols / breadcrumbsFind references  ","version":"Next","tagName":"h2"},{"title":"Customization​","type":1,"pageTitle":"Pyrefly in the IDE","url":"/en/docs/IDE/#customization","content":" By default, Pyrefly should work in the IDE with no configuration necessary. But to ensure your project is set up properly, see configurations.  The following configuration options are IDE-specific and exposed as VSCode settings:  python.pyrefly.disableLanguageServices [boolean: false]: by default, Pyrefly will provide both type errors and other language features like go-to definition, intellisense, hover, etc. Enable this option to keep type errors from Pyrefly unchanged but use VSCode's Python extension for everything else.python.pyrefly.disableTypeErrors [boolean: false]: by default, Pyrefly will provide type errors in your project. Enable this setting to disable type error squiggles appearing in the editor.  If the project configuration does not specify the Python interpreter, Pyrefly will use the interpreter selected in VSCode.  ","version":"Next","tagName":"h2"},{"title":"Issues?​","type":1,"pageTitle":"Pyrefly in the IDE","url":"/en/docs/IDE/#issues","content":" If you experience issues with the Pyrefly extension, please create an issue on github.  ","version":"Next","tagName":"h2"},{"title":"Other Editors​","type":1,"pageTitle":"Pyrefly in the IDE","url":"/en/docs/IDE/#other-editors","content":" Support for other editors is community-driven. If you would like to set this up, please contribute.  ","version":"Next","tagName":"h2"},{"title":"Jetbrains​","type":1,"pageTitle":"Pyrefly in the IDE","url":"/en/docs/IDE/#jetbrains","content":" An unofficial Jetbrains extension has been developed here  ","version":"Next","tagName":"h3"},{"title":"Neovim + lspconfig​","type":1,"pageTitle":"Pyrefly in the IDE","url":"/en/docs/IDE/#neovim--lspconfig","content":" With the lspconfig plugin and uv installed, you can use this configuration:  local lspconfig = require(&quot;lspconfig&quot;) local configs = require(&quot;lspconfig.configs&quot;) if not configs.pyrefly then configs.pyrefly = { cmd = { &quot;uv&quot;, &quot;run&quot;, &quot;pyrefly&quot;, &quot;lsp&quot; }, filetypes = { &quot;python&quot; }, root_dir = function(fname) return lspconfig.util.find_git_ancestor(fname) or vim.loop.os_homedir() end, settings = {}, }, end lspconfig.pyrefly.setup({})   ","version":"Next","tagName":"h3"},{"title":"Neovim 0.11+​","type":1,"pageTitle":"Pyrefly in the IDE","url":"/en/docs/IDE/#neovim-011","content":" Place the following file under ~/.config/nvim/lsp  return { cmd = { &quot;pyrefly&quot;, &quot;lsp&quot; }, filetypes = { &quot;python&quot; }, settings = {}, on_exit = function(code, _, _) vim.notify(&quot;Closing Pyrefly LSP exited with code: &quot; .. code, vim.log.levels.INFO) end, }   Then enable it in init.lua:  vim.lsp.enable({&quot;pyrefly&quot;})   ","version":"Next","tagName":"h3"},{"title":"Vim + Ale​","type":1,"pageTitle":"Pyrefly in the IDE","url":"/en/docs/IDE/#vim--ale","content":" Once this gets merged, you will only need:  let g:ale_linters = { ... \\ 'python': ['pyrefly'], ... \\ }  ","version":"Next","tagName":"h3"},{"title":"Migrating from Mypy","type":0,"sectionRef":"#","url":"/en/docs/migrating-from-mypy/","content":"","keywords":"","version":"Next"},{"title":"Running Pyrefly​","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#running-pyrefly","content":" Like mypy, pyrefly can be given a list of files to check:  $ pyrefly check file1.py file2.py   The easiest way to run pyrefly on all files in a project is to run it from the project root:  $ cd your/project $ pyrefly check   Pyrefly is designed to have sensible defaults, and you may not need to configure it at all. However, projects with existing mypy configs may want to configure pyrefly to suit their own needs.  ","version":"Next","tagName":"h2"},{"title":"Mypy Config Migration​","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#mypy-config-migration","content":" To make it as easy as possible to get started with pyrefly, we've provided a script for automatically migrating a mypy config to pyrefly.  $ pyrefly init --migrate path/to/your/project   This will search for an existing mypy.ini or pyproject.toml with a tool.mypy section, and then transform it into a pyrefly.toml (or [tool.pyrefly] section) while preserving as many options as possible. See init --help for more options.  We do recommend checking the resulting config for errors. While there is some overlap between mypy's config options and pyrefly's config options, it's not always possible to cleanly translate one config option to another.  If you'd rather start fresh with a hand-written config, please see the pyrefly configuration docs, or consider running pyrefly init (without --migrate!) to generate a basic config. If you run into any issues with config migration, please let us know!  ","version":"Next","tagName":"h2"},{"title":"Config Migration Details​","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#config-migration-details","content":" files, modules, and packages are combined into project_includes. This should work exactly the same for files and packages. Mypy doesn't recurse into modules, but pyrefly will.  Pyrefly makes an effort to transform the exclude regex into a list of filepath globs for project_excludes. This should excel on simple regexes, such as some/file.py|exclude_dir/, which becomes [&quot;**/some/file.py&quot;, &quot;**/exclude_dir/&quot;].  The ignore_missing_imports per-module config option is turned into a list of modules. For example:  [mypy-some.*.module] ignore_missing_imports = True   Becomes:  replace_imports_with_any = [&quot;some.*.module&quot;]   Mypy's follow_imports = &quot;skip&quot; is handled the same way.  Pyrefly does support mypy's module name pattern syntax: see Module Globbing in the configuration docs.  Mypy's follow_untyped_imports option is allowed to be global or per-module. The pyrefly equivalent, use_untyped_imports, is only global. This setting defaults to true unless the follow_untyped_imports is disabled in the [mypy] section of the migrated config.  ","version":"Next","tagName":"h3"},{"title":"Mypy Error Codes and Pyrefly Error Kinds​","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#mypy-error-codes-and-pyrefly-error-kinds","content":" Pyrefly maps Mypy's error codes to equivalent pyrefly error kinds. While not every error code has an equivalent error kind, we make an effort to ensure that pyrefly suppresses the same errors that mypy does.  This may lead to overly broad error suppressions, and you may want to consider removing some error kinds from the disable list. You can also use a SubConfig to selectively silence errors in specific files, or see Silencing Errors for how to suppress errors at the source.  See Error Kind Mapping for a table showing the relationship between type check diagnostic settings and error kinds.  ","version":"Next","tagName":"h3"},{"title":"Per-Module configs​","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#per-module-configs","content":" Mypy's per-module configs let you change a wide range of configuration options for modules matching a module wildcard. Pyrefly's SubConfigs are a similar mechanism that let you configure pyrefly's behavior for files matching a filepath glob. However, they support significantly fewer options, and only disable_error_code and enable_error_code will be migrated over to the pyrefly config.  ","version":"Next","tagName":"h3"},{"title":"Silencing Errors​","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#silencing-errors","content":" Like mypy, pyrefly has ways to silence specific error codes. Full details can be found in the Error Suppression docs  To silence an error on a specific line, add a disable comment above that line:  # pyrefly: ignore x: str = 1   To suppress all instances of an error, disable that error in the config:  [errors] import-error = false   This is equivalent to mypy's disable_error_code, though of course the error codes are different!  ","version":"Next","tagName":"h2"},{"title":"Error Kind Mapping​","type":1,"pageTitle":"Migrating from Mypy","url":"/en/docs/migrating-from-mypy/#error-kind-mapping","content":" This table shows the mapping between mypy's error codes and pyrefly's error kinds.  This table will be expanded as more diagnostics are supported.  Mypy\tPyreflyattr-defined\tmissing-attribute union-attr\tmissing-attribute ","version":"Next","tagName":"h3"},{"title":"Migration Guide","type":0,"sectionRef":"#","url":"/en/docs/migrating-to-pyrefly/","content":"","keywords":"","version":"Next"},{"title":"Migration Guides​","type":1,"pageTitle":"Migration Guide","url":"/en/docs/migrating-to-pyrefly/#migration-guides","content":" Migrating from Mypy - Guide for transitioning from Mypy to PyreflyMigrating from Pyright - Guide for transitioning from Pyright to Pyrefly  Choose the appropriate guide based on your current type checker to get started with your migration to Pyrefly. ","version":"Next","tagName":"h2"},{"title":"Pyrefly Frequently Asked Questions","type":0,"sectionRef":"#","url":"/en/docs/pyrefly-faq/","content":"","keywords":"","version":"Next"},{"title":"How do I pronounce Pyrefly?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#how-do-i-pronounce-pyrefly","content":" It's pronounced PIE-ur-fly, rhyming with &quot;firefly.&quot;  ","version":"Next","tagName":"h3"},{"title":"What is the relationship to Pyre?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#what-is-the-relationship-to-pyre","content":" Pyrefly is a ground-up rebuild that doesn’t share any core type checking code with Pyre. Not only is Pyrefly written in a new language (Rust instead of OCaml), but its design deviates in a major way from Pyre. Rust enables us to deliver substantial performance improvements and support multiple operating systems (including Windows). Beyond the core type checker itself, there are helper tooling and many lessons learned that we will take from Pyre and the community of Python type checking maintainers who have done tremendous work to get the state of type checking to where it is today.  ","version":"Next","tagName":"h3"},{"title":"Yet another Type Checker! Why not improve the ones adopted by the community already?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#yet-another-type-checker-why-not-improve-the-ones-adopted-by-the-community-already","content":" We are standing on the shoulders of giants. The contributions to Python typing by Mypy, Pyright, Pytype, Pyre and others have been invaluable. We borrowed concepts and learned from them as we rolled our own. Open source conformance matters to us a lot. While we might make some opinionated decisions, we'll adhere to the PEP process. Pyre was the only type checker that could scale for Meta’s needs and was starting to show its age, so we started with a ground-up rewrite aimed at usability and performance.  We built a custom engine for incremental computation and designed our type-checking algorithm based on years of experience in gradual typing theory and Rust expertise. By open-sourcing this technology we hope it can serve projects of any size well.  ","version":"Next","tagName":"h3"},{"title":"Why Rust?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#why-rust","content":" We would have preferred to write Pyrefly in Python, but we didn't think we could hit our ambitious performance goals using Python today (hopefully future work around free-threaded Python and JIT changes that). After ruling out Python, we wanted something that was safe, cross-platform, compiled to WASM (for a Playground experience). Rust and Go are probably the best choices for those goals, and our team at Meta had more experience with Rust.  ","version":"Next","tagName":"h3"},{"title":"Do you plan to build an LSP?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#do-you-plan-to-build-an-lsp","content":" Yes. See our roadmap for details.  ","version":"Next","tagName":"h3"},{"title":"Where do I report bugs?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#where-do-i-report-bugs","content":" Please open an issue on our GitHub page. You can leave feature requests there as well :) Our current goal is to get through our first major milestone, and after that we can look at bugs and features beyond the current roadmap.  ","version":"Next","tagName":"h3"},{"title":"Can I contribute to Pyrefly?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#can-i-contribute-to-pyrefly","content":" Please see the: contributing guidelines.  ","version":"Next","tagName":"h3"},{"title":"How do I know this project won't go unmaintained after a year?​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#how-do-i-know-this-project-wont-go-unmaintained-after-a-year","content":" Great question. We have made a substantial investment in Pyrefly, use it internally and aligned open source maintainability as a key principle for starting this project in the first place. We’re in it for the long haul. Using it is the best way to encourage further investment from our leadership.  ","version":"Next","tagName":"h3"},{"title":"This is cool, I want to learn more about the technical details.​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#this-is-cool-i-want-to-learn-more-about-the-technical-details","content":" See our README.md for the high level design. We plan to add more detailed documentation along with announcements on https://engineering.fb.com  ","version":"Next","tagName":"h3"},{"title":"I don't like Python's Type System. Stop wasting your time.​","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#i-dont-like-pythons-type-system-stop-wasting-your-time","content":" Tell us more - seriously! We want to hear your objections to typing. We hope that better tooling, improvements to the type system and well typed libraries will help provide make development easier. If all else fails our fast code navigation and inference algorithm might spark joy in your IDE, so give us a chance.  Curious about something else or just want to chat about bolting types onto Python, join us on Discord. ","version":"Next","tagName":"h3"},{"title":"Migrating from Pyright","type":0,"sectionRef":"#","url":"/en/docs/migrating-from-pyright/","content":"","keywords":"","version":"Next"},{"title":"Running Pyrefly​","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#running-pyrefly","content":" Like pyright, pyrefly can be given a list of files to check:  $ pyrefly check file1.py file2.py   The easiest way to run pyrefly on all files in a project is to run it from the project root:  $ cd your/project $ pyrefly check   Pyrefly doesn't need a config file to start checking your code. Its sensible defaults are designed to work well for most projects. However, projects with existing pyright configs may want to configure pyrefly to suit their own needs.  ","version":"Next","tagName":"h2"},{"title":"Pyright Config Migration​","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#pyright-config-migration","content":" To make it as easy as possible to get started with pyrefly, we've provided a script for automatically migrating a pyright config to pyrefly.  $ pyrefly init --migrate path/to/your/project   This will search for an existing pyrightconfig.json or pyproject.toml with a tool.pyright section, and then transform it into a pyrefly.toml (or [tool.pyrefly] section) while preserving as many options as possible. See init --help for more options.  There is a significant overlap between pyright's and pyrefly's configuration options, so migration is pretty straightforward. However, it may be worth checking the generated config for errors, just in case.  If you'd rather start fresh with a hand-written config, please see the pyrefly configuration docs, or consider running pyrefly init (without --migrate!) to generate a basic config. If you run into any issues with config migration, please let us know!  ","version":"Next","tagName":"h2"},{"title":"Config Migration Details​","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#config-migration-details","content":" When it comes to listing files, pyright uses just paths, while pyrefly supports glob patterns. Thankfully, paths are a subset of glob patterns, so pyrefly can just use the paths as-is. You could consider manually simplifying the paths into glob patterns, but it's not necessary.  Pyright supports four platforms: Windows, Linux, Darwin (macOS), and All. Since pyrefly only supports Python's supported platforms, we choose to treat &quot;All&quot; as &quot;linux&quot;.  ","version":"Next","tagName":"h2"},{"title":"Type Check Diagnostic Settings and Error Kinds​","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#type-check-diagnostic-settings-and-error-kinds","content":" Pyrefly maps pyright's type check diagnostics settings to equivalent pyrefly error kinds. While not every diagnostic setting has an equivalent error kind, we make an effort to ensure that pyrefly suppresses the same errors that pyright does.  This may lead to overly broad error suppressions, and you may want to consider removing some error kinds from the disable list. You can also use a SubConfig to selectively silence errors in specific files, or see Silencing Errors for how to suppress errors at the source.  See Error Kind Mapping for a table showing the relationship between type check diagnostic settings and error kinds.  ","version":"Next","tagName":"h3"},{"title":"Execution Environments​","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#execution-environments","content":" Pyright's execution environments let you customize the Python version, platform, module search paths, and diagnostic settings for some part of your project. Pyrefly's SubConfigs are a similar mechanism that let you configure pyrefly's behavior for files matching a filepath glob. However, subconfigs do not support changing the Python version, platform, or module search paths.  Diagnostic settings are carried over to the equivalent subconfig, using the mapping mentioned above.  ","version":"Next","tagName":"h3"},{"title":"Silencing Errors​","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#silencing-errors","content":" Like pyright, pyrefly has ways to silence specific error codes. Full details can be found in the Error Suppression docs.  To silence an error on a specific line, add a disable comment above that line:  # pyrefly: ignore x: str = 1   To suppress all instances of an error, disable that error in the config:  [errors] import-error = false   This is similar to pyright's type check rule overrides, though of course the error codes are different!  ","version":"Next","tagName":"h2"},{"title":"Error Kind Mapping​","type":1,"pageTitle":"Migrating from Pyright","url":"/en/docs/migrating-from-pyright/#error-kind-mapping","content":" This table shows the mapping between pyright's type check diagnostics settingsand pyrefly's error kinds.  This table will be expanded as more diagnostics are supported.  Pyright\tPyreflyreportMissingImports\timport-error reportMissingModuleSource\timport-error ","version":"Next","tagName":"h2"},{"title":"Typing Features and PEPS","type":0,"sectionRef":"#","url":"/en/docs/python-features-and-peps/","content":"Typing Features and PEPS Typing Features and PEPS available in each Python Version. Feature (click PEP for details)\tWhat it adds / looks like\tIntroduced inPEP 484 -- Core type hints &amp; typing module\tdef add(a: int, b: int) -&gt; int:\t3.5 PEP 526 -- Variable annotations\tcount: int = 0\t3.6 PEP 563 -- from __future__ import annotations (lazy eval)\tAnnotations stored as strings\t3.7 (future‑flag) PEP 544 -- Protocols (structural typing)\tclass Jsonable(Protocol): ...\t3.8 PEP 589 -- TypedDict\tclass User(TypedDict): ...\t3.8 PEP 586 -- Literal types\tdef log(level: Literal[&quot;info&quot;,&quot;warn&quot;]): ...\t3.8 PEP 591 -- Final qualifier\tTOKEN: Final[str] = &quot;...&quot;\t3.8 PEP 585 -- Built‑in generics\tlist[int], dict[str, Any]\t3.9 PEP 593 -- Annotated\tx: Annotated[int, &quot;units=px&quot;]\t3.9 PEP 604 -- Union syntax\tint | None\t3.10 PEP 612 -- ParamSpec / Concatenate\tdecorator‑safe generics\t3.10 PEP 613 -- TypeAlias qualifier\tVector: TypeAlias = list[float]\t3.10 PEP 647 -- TypeGuard for narrowing\tdef is_str(x) -&gt; TypeGuard[str]: ...\t3.10 PEP 655 -- Required / NotRequired for TypedDict\toptional vs. mandatory keys\t3.11 PEP 646 -- Variadic generics (TypeVarTuple, Unpack)\ttensor shapes, 2‑D arrays, ...\t3.11 PEP 673 -- Self type\tfluent APIs: def set(...) -&gt; Self:\t3.11 PEP 681 -- dataclass_transform helper\tlibraries like Pydantic, attrs\t3.11 PEP 695 -- Class‑level generics syntax\tclass Box[T]: ...\t3.12 PEP 698 -- @override decorator\tflag intentional overrides\t3.13 PEP 649 -- New deferred‑eval algorithm (replaces PEP 563)\tbecomes the default\t3.14","keywords":"","version":"Next"},{"title":"Python Typing for New Developers","type":0,"sectionRef":"#","url":"/en/docs/python-typing-for-beginners/","content":"","keywords":"","version":"Next"},{"title":"1. What is a Type Hint in Python?​","type":1,"pageTitle":"Python Typing for New Developers","url":"/en/docs/python-typing-for-beginners/#1-what-is-a-type-hint-in-python","content":" A type hint in Python is a way to indicate the expected data type of a variable, function parameter, or return value. It's a hint to other developers (and to tools like type checkers and IDEs) about what type of data should be used with a particular piece of code.  Type hints are not enforced at runtime by Python itself, but they can be used by third-party tools (like Pyrefly) to catch type-related errors before your code runs. They also serve as documentation, making it easier for others to understand how to use your code. Here's an example of a simple function with type hints:  def greet(name: str) -&gt; None: print(f&quot;Hello, {name}!&quot;)   ","version":"Next","tagName":"h2"},{"title":"2. Why Bother with Type Hints?​","type":1,"pageTitle":"Python Typing for New Developers","url":"/en/docs/python-typing-for-beginners/#2-why-bother-with-type-hints","content":" Python is a dynamically typed language, which means you can write code without declaring types. However, this can lead to bugs or ambiguity in your code.  TL;DR  Catch bugs before running the code.Improve editor autocomplete &amp; refactors.Turn your code into living documentation.  # Without hints – is &quot;times&quot; a str, int, or list? def repeat(text, times): return text * times # With hints – intent is crystal clear. def repeat(text: str, times: int) -&gt; str: return text * times  ","version":"Next","tagName":"h2"},{"title":"Can you spot the bug?​","type":1,"pageTitle":"Python Typing for New Developers","url":"/en/docs/python-typing-for-beginners/#can-you-spot-the-bug","content":" class Rectangle: width: int height: int def __init__(self, width: int, height: int) -&gt; None: self.width = width self.height = height rect = Rectangle(width=100, height=50) area = rect.width * rect.hieght print(area)   Spelling is hard! Let's add the dataclass decorator to our class definition. This will generate a constructor for us, and also add a few other useful methods.  #Pyrefly will catch this spelling error before you run the code from dataclasses import dataclass @dataclass class Rectangle: width: int height: int rect = Rectangle(width=100, height=50) area = rect.width * rect.hieght  ","version":"Next","tagName":"h3"},{"title":"3. Primitive Types​","type":1,"pageTitle":"Python Typing for New Developers","url":"/en/docs/python-typing-for-beginners/#3-primitive-types","content":" Since Python 3.9 you can use all the primitive types directly as annotations.  age: int = 30 height: float = 1.85 name: str = &quot;Tyler Typer&quot; is_admin: bool = False  You can also specify a parameter as optional by using Optional type, or now with the | None syntax.  # Optional typing example from typing import Optional middle_name: Optional[str] = None # classic nickname: str | None = None # 3.10+ shorthand  ","version":"Next","tagName":"h2"},{"title":"4. Collections​","type":1,"pageTitle":"Python Typing for New Developers","url":"/en/docs/python-typing-for-beginners/#4-collections","content":" ","version":"Next","tagName":"h2"},{"title":"Syntax Examples​","type":1,"pageTitle":"Python Typing for New Developers","url":"/en/docs/python-typing-for-beginners/#syntaxexamples","content":" List of numbers list[int] scores: list[int] = [98, 87, 91]Tuple of two floats tuple[float, float] point: tuple[float, float] = (3.0, 4.0)Dict of str -&gt; int dict[str, int] inventory: dict[str, int] = {&quot;apples&quot;: 5}Set of strings set[str] authors: set[str] = {&quot;Bob&quot;, &quot;Eve&quot;}  Since Python 3.9 you can subscript built‑ins directly—no need for from typing import List.  ","version":"Next","tagName":"h3"},{"title":"5. Functions​","type":1,"pageTitle":"Python Typing for New Developers","url":"/en/docs/python-typing-for-beginners/#5-functions","content":" # Simple function def add(a: int, b: int) -&gt; int: return a + b  Default values keep their annotation:  # Function with default value def greet(name: str, polite: bool = True) -&gt; str: return &quot;Hello!&quot; if polite else f&quot;Yo {name}&quot;  Variable‑length arguments:  # Variable length functions from collections.abc import Callable Logger = Callable[[str], None] def debug(*msgs: str, log: Logger | None = print) -&gt; None: for m in msgs: if log is not None: log(m) else: print(m)  ","version":"Next","tagName":"h2"},{"title":"6. Get Type Hint Signals Directly in Your Editor​","type":1,"pageTitle":"Python Typing for New Developers","url":"/en/docs/python-typing-for-beginners/#6-get-type-hint-signals-directly-in-your-editor","content":" You can download the Pyrefly extension for VSCode to get type hint signals directly in your IDE.  Next, install Pyrefly and check some code:  # Fast, zero‑config pip install pyrefly pyrefly check ./my_sample.py # Check whole directories pyrefly check app/ tests/   Create a pyrefly.toml file to configure your project. Instructions here. ","version":"Next","tagName":"h2"},{"title":"Error Kinds","type":0,"sectionRef":"#","url":"/en/docs/error-kinds/","content":"","keywords":"","version":"Next"},{"title":"annotation-mismatch​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#annotation-mismatch","content":" This error indicates a mismatch between multiple annotations for a single variable. This is relatively uncommon, but it can happen in if-statements:  if some_cond: x: int = 1 else: x: str = &quot;two&quot; # Inconsistent type annotations for x: str, int [annotation-mismatch]   It can be helpful to annotate the variable before branch, especially if there is a useful default value for it. For example:  x: str = &quot;default&quot; if some_cond: x = &quot;actual value&quot;   ","version":"Next","tagName":"h2"},{"title":"assert-type​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#assert-type","content":" An assert-type error is raised when a typing.assert_type() call fails.  This error kind should never be suppressed, since that rather defeats the point of of typing.assert_type().  ","version":"Next","tagName":"h2"},{"title":"async-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#async-error","content":" async-error is reported when attempting to await on something that is not awaitable. This may indicate that a function should have been marked async but wasn't.  def some_func() -&gt; None: ... await some_func() # Expression is not awaitable [async-error]   This will also arise if the context manager used in an async with statement has __aenter__ and __aexit__ methods that are not marked async.  The fix is to use an async function in the await. This may mean making the function async or finding an existing async function to use instead.  ","version":"Next","tagName":"h2"},{"title":"bad-argument-count​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-argument-count","content":" This error arises when a function is called with the wrong number of arguments.  def takes_three(one: int, two: int, three: int) -&gt; complex: ... take_three(3, 2) # Expected 1 more positional argument [bad-argument-count]   Note that missing-argument will be raised if pyrefly can identify that specific arguments are missing. As such, this error is more likely to appear when too many args are supplied, rather than too few.  This example shows both kinds of errors:  from typing import Callable def apply(f: Callable[[int, int], int]) -&gt; int: return f(1) # Expected 1 more positional argument [bad-argument-count] apply() # Missing argument `f` in function `apply` [missing-argument]   ","version":"Next","tagName":"h2"},{"title":"bad-argument-type​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-argument-type","content":" This error indicates that the function was called with an argument of the wrong type.  def example(x: int) -&gt; None: ... example(&quot;one&quot;) # Argument `Literal['two']` is not assignable to parameter `x` with type `int` in function `example` [bad-argument-type]   This can also happen with *args and **kwargs:  def bad_args(*args: int) -&gt; None: ... bad_args(1, &quot;two&quot;) # Argument `Literal['two']` is not assignable to parameter with type `int` in function `bad_args` [bad-argument-type]   def bad_kwargs(**kwargs: int) -&gt; None: ... bad_args(x=1, y=&quot;two&quot;) # Keyword argument `y` with type `Literal['two']` is not assignable to kwargs type `int` in function `bad_kwargs` [bad-argument-type]   ","version":"Next","tagName":"h2"},{"title":"bad-assignment​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-assignment","content":" The most common cause of this error is attempting to assign a value that conflicts with the variable's type annotation.  x: str = 1 # `Literal[1]` is not assignable to `str` [bad-assignment]   However, it can occur in several other situations.  Here, x is marked as Final, so assigning a new value to it is an error.  from typing import Final x: Final = 1 x = 2 # `x` is marked final [bad-assignment]   In another case, attempting to annotate an assignment to an instance attribute raises this error.  class A: x: int a = A() a.x: int = 2 # Type cannot be declared in assignment to non-self attribute `a.x` [bad-assignment]   ","version":"Next","tagName":"h2"},{"title":"bad-class-definition​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-class-definition","content":" This error indicates that there is something wrong with the class definition. It tends to be a bit rarer, since most issues would be tagged with other error kinds, such asannotation-mismatch or one of the function errors. inheritance has its own complexities, so it has its own error kind called invalid-inheritance.  One place you may see it is dynamic class generation:  from enum import Enum Ex = Enum(&quot;Ex&quot;, [(&quot;Red&quot;, 1), (&quot;Blue&quot;, 2), (&quot;Red&quot;, 3)]) # Duplicate field `Red` [bad-class-definition]   However, it is best practice to use the class syntax if possible, which doesn't treat duplicate names as an error.  ","version":"Next","tagName":"h2"},{"title":"bad-function-definition​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-function-definition","content":" Like bad-class-definition, this error kind is uncommon because other error kinds are used for more specific issues. For example, argument order is enforced by the parser, so def f(x: int = 1, y: str) is a parse-error.  ","version":"Next","tagName":"h2"},{"title":"bad-keyword-argument​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-keyword-argument","content":" bad-keyword-argument pops up when a keyword argument is given multiple values:  def f(x: int) -&gt; None: pass f(x=1, x=2)   However, this is often accompanied by a parse-error for the same issue.  ","version":"Next","tagName":"h2"},{"title":"bad-override​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-override","content":" When a subclass overrides a field or method of its base class, care must be taken that the override won't cause problems.  Some of these are obvious:  class Base: def f(self, a: int) -&gt; None: pass class NoArg(Base): def f(self) -&gt; None: pass class WrongType(Base): def f(self, a: str) -&gt; None: pass def uses_f(b: Base) -&gt; None: b.f(1)   These errors are rather obvious: uses_f will fail if given a NoArg or WrongType instance, because those methods don't expect an int argument!  The guiding idea here is the Liskov Substitution Principle, the idea that a subclass can stand in for a base class at any point without breaking the program.  This can be a little subtle at first blush. Consider:  class Base: def f(self, a: int) -&gt; None: pass class Sub(Base): def f(self, a: float) -&gt; None: pass   Is this OK? Yes! int is treated as a subclass of float, or to put it another way, a function that accepts float can accept every int. That means everywhere that we call Base.f can safely call Sub.f.  The opposite case, where Base.f takes float and Sub.f takes int, is an error because Sub.f cannot accept every float value.  ","version":"Next","tagName":"h2"},{"title":"bad-return​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-return","content":" Arises when a function does not return a value that is compatible with the function's return type annotation.  def bad_return() -&gt; None: return 1   Real-world examples are often less obvious, of course, due to complex control flow and type relationships.  This error is also raised for generator functions:  from typing import Generator # Generator has 3 types: the yield, send, and return types. def bad_gen() -&gt; Generator[int, None, str]: yield 1 return 2 # should be a str!   ","version":"Next","tagName":"h2"},{"title":"bad-specialization​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-specialization","content":" &quot;Specialization&quot; refers to instantiating a generic type with a concrete type. For example, list is a generic type, and list[int] is that type specialized with int.  Each generic type has an expected number of type vars, and each type var can be bound or constrained. Attempting to use specialize a generic type in a way that violates these specifications will result in a bad-specialization error:  x: list[int, str]   ","version":"Next","tagName":"h2"},{"title":"bad-unpacking​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-unpacking","content":" An error caused by unpacking, such as attempting to unpack a list, tuple, or iterable into the wrong number of variables.  def two_elems() -&gt; tuple[int, str]: return (1, &quot;two&quot;) a, b, c = two_elems()   Note that pyrefly can only report this error if it knows how many elements the thing being unpacked has.  # A bare `tuple` could have any number of elements def two_elems() -&gt; tuple: return (1, &quot;two&quot;) a, b, c = two_elems()   ","version":"Next","tagName":"h2"},{"title":"delete-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#delete-error","content":" This error occurs when attempting to del something that cannot be deleted.  Besides obvious things like built-in values (you can't del True!), some object attributes are protected from deletion. For example, read-only and required TypedDict fields cannot be deleted.  ","version":"Next","tagName":"h2"},{"title":"import-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#import-error","content":" An error related to the import mechanism, such as when a module cannot be found.  The error message will include which paths were searched, such as the site package paths. You may be missing a dependency, or you may need to inform Pyrefly where the module lives. See Configuration for further information.  ","version":"Next","tagName":"h2"},{"title":"index-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#index-error","content":" Attempting to access a container with an incorrect index. This only occurs when Pyrefly can statically verify that the index is incorrect, such as with a fixed-length tuple.  def add_three(x: tuple[int, int]) -&gt; int: return x[0] + x[1] + x[2]   Pyrefly also knows the keys of TypedDicts, but those have their own error kind.  ","version":"Next","tagName":"h2"},{"title":"internal-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#internal-error","content":" Ideally you'll never see this one. If you do, please consider filing a bug.  ","version":"Next","tagName":"h2"},{"title":"invalid-annotation​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-annotation","content":" There are several reasons why an annotation may be invalid. The most common case is misusing a typing special form, such as typing.Final, typing.ClassVar, typing.ParamSpec, and so on.  from typing import * # Final must have a value a: Final # ClassVar can only be used in a class body b: ClassVar[int] = 1   The error messages will explain how the special form is being misused. Consult the typing docs and typing spec for more information.  ","version":"Next","tagName":"h2"},{"title":"invalid-argument​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-argument","content":" This error is used to indicate an issue with an argument to special typing-related functions.  For example, typing.NewType is a handy special form for creating types that are distinct from a base type.  from typing import * # The first arg must match the name! Mismatch = NewType(&quot;Wrong Name&quot;, int) # NewTypes cannot be used in isinstance. UserId = NewType(&quot;UserId&quot;, int) if isinstance(1, UserId): ...   ","version":"Next","tagName":"h2"},{"title":"invalid-inheritance​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-inheritance","content":" An error caused by incorrect inheritance in a class or type definition. This can pop up in quite a few cases:  Trying to subclass something that isn't a class.Subclassing a type that does not support it, such as a NewType or a Final class.Attempting to mix Protocols with non-Protocol base classes.Trying to make a generic enum.Trying to give a TypedDict a metaclass.  And so on!  ","version":"Next","tagName":"h2"},{"title":"invalid-literal​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-literal","content":" typing.Literal only allows a limited set of types as parameters. Attempting to use Literal with anything else is an error.  from typing import Literal # These are legal Literal[1.0] Literal['a', 'b', 'c'] # This is not class A: ... Literal[A()]   ","version":"Next","tagName":"h2"},{"title":"invalid-overload​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-overload","content":" The @overload decorator requires that the decorated function has at least two overloaded signatures and a base implementation.  from typing import * @overload def no_base(x: int) -&gt; None: pass @overload def no_base(x: str) -&gt; int: pass   @overload def just_one(x: int) -&gt; None: pass def just_one(x: str) -&gt; None: ...   ","version":"Next","tagName":"h2"},{"title":"invalid-param-spec​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-param-spec","content":" This error is reported when typing.ParamSpec is defined incorrectly or misused. For example:  from typing import * P = ParamSpec(&quot;Name Must Match!&quot;) P1 = ParamSpec(&quot;P1&quot;) P2 = ParamSpec(&quot;P2&quot;) def f(x, *args: P1.args, **kwargs: P2.kwargs) -&gt; None: pass   Here, P1.args and P2.kwargs can't be used together; *args and **kwargs must come from the same ParamSpec.  ","version":"Next","tagName":"h2"},{"title":"invalid-super-call​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-super-call","content":" super() has a few restrictions on how it is called.  super() can be called without arguments, but only when used inside a method of a class:  class Legal(Base1, Base2): def f(self) -&gt; None: super().f() def illegal(arg: SomeType) -&gt; None: super().f()   When the function is called with two arguments, like super(T, x), then T must be a type, and the second argument is either an object where isinstance(x, T) is true or a type where issubclass(x, T) is true.  ","version":"Next","tagName":"h2"},{"title":"invalid-syntax​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-syntax","content":" This error covers syntactical edge cases that are not flagged by the parser.  For example:  x: list[int] = [0, 2, 3] x[0]: int = 1   It's not a parse error for an assignment to have an annotation, but it is forbidden by the type checker to annotate assignment to a subscript like x[0].  ","version":"Next","tagName":"h2"},{"title":"invalid-type-var​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-type-var","content":" An error caused by incorrect usage or definition of a TypeVar. A few examples:  from typing import TypeVar # Old-style TypeVars must be assigned to a matching variable. Wrong = TypeVar(&quot;Name&quot;) # PEP 695-style TypeVars can be constrained, but there must be at least two: def only_one_constriant[T: (int,)](x: T) -&gt; T: ... # It's also illegal to mix the two styles together. T = TypeVar(&quot;T&quot;) def mixed[S](a: S, b: T) -&gt; None: ...   ","version":"Next","tagName":"h2"},{"title":"invalid-type-var-tuple​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-type-var-tuple","content":" An error caused by incorrect usage or definition of a TypeVarTuple.  TypeVarTuple has similar error cases to TypeVar, but also a few of its own. For example:  from typing import TypeVarTuple Ts = TypeVarTuple(&quot;Ts&quot;) # TypeVarTuples must always be unpacked: bad: tuple[Ts] = (...) good: tuple[*Ts] = (...) # Only one TypeVarTuple is allowed in a list of type arguments: def two_tups[*Xs, *Ys](xs: tuple[*Xs], ys: tuple[*Ys]) -&gt; None: ...   ","version":"Next","tagName":"h2"},{"title":"invalid-yield​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-yield","content":" This error arises when yield is used in a way that is not allowed. For example:  from typing import Generator for _ in range(1, 10): yield &quot;can't yield outside of a function!&quot; def bad_yield_from() -&gt; Generator[int, None, None]: # `yield from` can only be used with iterables. yield from 1   ","version":"Next","tagName":"h2"},{"title":"match-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#match-error","content":" This error is used in two cases.  The first is when there is an issue with a match statement. For example, Ex only has 2 fields but the case lists 3:  class Ex: __match_args__ = ('a', 'b') def __init__(self, a: int, b: str) -&gt; None: self.a = a self.b = b def do(x: Ex) -&gt; None: match x: case Ex(a, b, c): print(&quot;This is an error&quot;)   It is also used when __match_args__ is defined incorrectly. It must be a tuple of the names of the class's attributes as literal strings. For class Ex in the previous example, __match_args__ = ('a', 'c') would be an error because Ex.c does not exist.  ","version":"Next","tagName":"h2"},{"title":"missing-argument​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#missing-argument","content":" An error caused by calling a function without all the required arguments.  def takes_two(x: int, y: int) -&gt; int: return x + y takes_two(1)   ","version":"Next","tagName":"h2"},{"title":"missing-attribute​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#missing-attribute","content":" This error is raised when attempting to access an attribute that does not exist on the given object or module.  In the case of modules, attempting to import an nonexistent name will raise `missing-module-attribute instead.  import os from os import bacarat # missing-module-attribute os.jongleur() # missing-attribute   Note that objects with type Any will never raise this error.  ","version":"Next","tagName":"h2"},{"title":"missing-module-attribute​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#missing-module-attribute","content":" Arises when attempting to import a name that does not exist from a module.  This is distinct from import-error, which is used when the module being imported does not exist, and missing-attribute, when access attributes of the module.  import this_does_not_exist # import-error import os.bacarat # import-error from os import joker # missing-module-attribute os.perkeo # missing-attribute   In this example, os.bacarat is treated as a module name, so failing to find it results in an import-error.from os import joker does not tell us if joker is a module, class, function, etc., so it is treated as the more general missing-module-attribute.  ","version":"Next","tagName":"h2"},{"title":"no-access​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#no-access","content":" The no-access error indicates that an attribute exists, but it cannot be used in this way.  For example, classes do not have access to their instances' attributes:  class Ex: def __init__(self) -&gt; None: self.meaning: int = 42 del Ex.meaning # no-access   ","version":"Next","tagName":"h2"},{"title":"no-matching-overload​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#no-matching-overload","content":" This error is similar to the other bad function call errors, but specifically for cases where a function decorated with @overload is called with arguments that do not match any of the overloaded variations.  For example, neither of the signatures of f can take an argument of type float:  from typing import overload @overload def f(x: int) -&gt; int: ... @overload def f(x: str) -&gt; str: ... def f(x: int | str) -&gt; int | str: return x f(1.0)   ","version":"Next","tagName":"h2"},{"title":"not-a-type​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#not-a-type","content":" This indicates an attempt to use something that isn't a type where a type is expected. In most cases, a more specific error kind is used.  You may see this error around incorrect type aliases:  class A: ... # Not an alias, just a string! X = &quot;A&quot; x: X = ... # X is not a type alias, so this is illegal   ","version":"Next","tagName":"h2"},{"title":"not-callable​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#not-callable","content":" A straightforward error: something that is not a function was used as if it were a function.  One interesting place this error may occur is with decorators:  x = 1 @x # not-callable def foo() -&gt; None: ...   ","version":"Next","tagName":"h2"},{"title":"not-iterable​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#not-iterable","content":" This is most likely to be seen in a for loop:  x = 1 # Or some other value for val in x: # not-iterable ...   ","version":"Next","tagName":"h2"},{"title":"parse-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#parse-error","content":" An error related to parsing or syntax. This covers a variety of cases, such as function calls with duplicate keyword args, some poorly defined functions, and so on.  ","version":"Next","tagName":"h2"},{"title":"read-only​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#read-only","content":" This error indicates that the attribute being accessed does exist but cannot be modified.  For example, a @property with no setter cannot be assigned to:  class Ex: @property def meaning(self) -&gt; int: return 42 x = Ex() x.meaning = 0   ","version":"Next","tagName":"h2"},{"title":"reveal-type​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#reveal-type","content":" Pyrefly uses this error to communicate the output of the reveal_type function.  ","version":"Next","tagName":"h2"},{"title":"type-alias-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#type-alias-error","content":" An error related to the definition or usage of a typing.TypeAlias. Many of these cases are covered by invalid-annotation, so this error specifically handles illegal type alias values:  from typing import TypeAlias x = 2 Bad: TypeAlias = x   ","version":"Next","tagName":"h2"},{"title":"typed-dict-key-error​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#typed-dict-key-error","content":" This error arises when TypedDicts are used with incorrect keys, such as a key that does not exist in the TypedDict.  from typing import TypedDict class Ex(TypedDict): a: int b: str def test(x: Ex) -&gt; None: # These two keys don't exist x.nope x[&quot;wrong&quot;] # TypedDict keys must be strings! x[1]   ","version":"Next","tagName":"h2"},{"title":"unbound-name​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#unbound-name","content":" This error corresponds to the runtime NameError, indicating that a variable is referenced but does not exist.  def do_things(stuff: list[int]) -&gt; str: ... do_thing([1, 2]) # typo! Or, unbound-name   ","version":"Next","tagName":"h2"},{"title":"unexpected-keyword​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#unexpected-keyword","content":" A function was called with an extra keyword argument.  def two_args(a: int, b: int) -&gt; int: ... two_args(a=1, b=2, c=3)   ","version":"Next","tagName":"h2"},{"title":"unknown-name​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#unknown-name","content":" unknown-name occurs when attempting to load a name from another scope, but the name cannot be found.  def where() -&gt; None: # There is no spoon: unknown-name global spoon   ","version":"Next","tagName":"h2"},{"title":"unsupported-operand​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#unsupported-operand","content":" This error arises when attempting to perform an operation between values of two incompatible types. Since many Python operators are actually syntactic sugar for function calls, many operations will result in bad-argument-type errors.  An exception is the in operator, which fails when looking for a value in something that does not support in:  if &quot;hello&quot; in 1: # int doesn't support `in`! ...   ","version":"Next","tagName":"h2"},{"title":"unsupported​","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#unsupported","content":" This error indicates that pyrefly does not currently support a typing feature. ","version":"Next","tagName":"h2"},{"title":"Typing for Python Developers","type":0,"sectionRef":"#","url":"/en/docs/typing-for-python-developers/","content":"","keywords":"","version":"Next"},{"title":"Types with Inference​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#types-with-inference","content":" Static analyzers can often infer types from your code—no annotations required. Pyrefly takes this a step further.  # Basic Inference answer = 42 reveal_type(answer) # hover to reveal type fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] scores = {&quot;math&quot;: 95, &quot;science&quot;: 90} def greet(name): return f&quot;Hello, {name}!&quot; message = greet(&quot;World&quot;)  ","version":"Next","tagName":"h3"},{"title":"Where Inference Shines ✨​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#where-inference-shines-","content":" Constant assignments (answer = 42 -&gt; int)List/tuple/dict literals with uniform elements (names = [&quot;A&quot;, &quot;B&quot;] -&gt; list[str])Return types if parameter types are annotated:  def add(a: int, b: int): # ✅ param annotations return a + b # 🔍 return inferred -&gt; int  ","version":"Next","tagName":"h3"},{"title":"When to Add Hints​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#when-to-add-hints","content":" Public APIs (library or service boundaries)Mixed collections (list[int | str])Callable signatures (decorators, callbacks)  ","version":"Next","tagName":"h3"},{"title":"Define Types Inline​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#define-types-inline","content":" ","version":"Next","tagName":"h2"},{"title":"The Basics​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#the-basics","content":" Python's built-in types can be used to write many type hints.  # Example: Basic Types from typing import reveal_type age: int = 5 reveal_type(age) # revealed type: int age = &quot;oops&quot; name: str = &quot;John&quot; reveal_type(name) # revealed type: str numbers: list[int] = [1, 2, 3] reveal_type(numbers) # revealed type: list[int] names: list[str] = [&quot;John&quot;, &quot;Jane&quot;] reveal_type(names) # revealed type: list[str] person: dict[str, str] = {&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: &quot;30&quot;} reveal_type(person) # revealed type: dict[str, str] is_admin = True reveal_type(is_admin) # revealed type: Literal[True]  ","version":"Next","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#functions","content":" Defining the parameter and return types for a function doesn't just help prevent bugs, but it makes it easier to navigate in other files. You don't always need to define a return type - we'll do our best to infer it for you! We can't always get it right and an explicit return type will help your IDE navigate faster and more accurately.  # Example: Functions from typing import reveal_type def greet(name: str) -&gt; str: return f&quot;Hello, {name}!&quot; greet(&quot;Pyrefly&quot;) def whatDoesThisFunctionReturnAgain(a: int, b: int): return a + b reveal_type(whatDoesThisFunctionReturnAgain(2, 3)) # revealed type: int  ","version":"Next","tagName":"h3"},{"title":"Advanced Types​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#advanced-types","content":" ","version":"Next","tagName":"h2"},{"title":"Composing Types​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#composing-types","content":" The real power comes from composing smaller pieces into richer shapes.  ","version":"Next","tagName":"h3"},{"title":"Unions & Optional​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#unions--optional","content":" # Union and Optional Types from typing import Optional def to_int(data: str | bytes | None) -&gt; Optional[int]: if data is None: return None if isinstance(data, bytes): data = data.decode() return int(data)  ","version":"Next","tagName":"h3"},{"title":"Generics​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#generics","content":" Generics allow you to define reusable functions and classes that work with multiple types. This feature enables you to write more flexible and adaptable code.  # Example: Generic Classes from typing import reveal_type class C[T]: def __init__(self, x: T): self.x = x def box(self) -&gt; list[T]: return [self.x] c = C(0) reveal_type(c.box()) # revealed type: list[int]  ","version":"Next","tagName":"h3"},{"title":"Protocols​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#protocols","content":" Protocols enable structural typing, which allows you to define interfaces without explicit inheritance. This feature helps you write more modular and composable code.  # Example: Structural Typing with Protocols from typing import Iterable, Protocol class Writer(Protocol): def write(self) -&gt; None: ... class GoodWorld: def write(self) -&gt; None: print(&quot;Hello world!&quot;) class BadWorld: pass def f(writer: Writer): pass f(GoodWorld()) # OK f(BadWorld()) # ERROR!  ","version":"Next","tagName":"h3"},{"title":"Structural Types​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#structural-types","content":" Python also employs a structural type system, often referred to as &quot;duck typing.&quot; This concept is based on the idea that if two objects have the same shape or attributes, they can be treated as being of the same type.  ","version":"Next","tagName":"h2"},{"title":"Dataclasses​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#dataclasses","content":" Dataclasses allow you to create type-safe data structures while minimizing boilerplate.  # Example: Dataclasses from dataclasses import dataclass @dataclass class Point: x: float y: float Point(x=0.0, y=0.0) # OK Point(x=0.0, y=&quot;oops&quot;) # ERROR!  ","version":"Next","tagName":"h3"},{"title":"TypedDict​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#typeddict","content":" Typed dictionaries enable you to define dictionaries with specific key-value types. This feature lets you bring type safety to ad-hoc dictionary structures without major refactoring.  # Example: TypedDict from typing import TypedDict class Movie(TypedDict): name: str year: int good_movie: Movie = {&quot;name&quot;: &quot;Toy Story&quot;, &quot;year&quot;: 1995} # OK bad_movie: Movie = {&quot;name&quot;: &quot;The Room&quot;, &quot;year&quot;: &quot;2003&quot;} # ERROR!  ","version":"Next","tagName":"h3"},{"title":"Overloads​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#overloads","content":" Overloads allow you to define multiple function signatures for a single function. Like generics, this feature helps you write more flexible and adaptable code.  # Example: Overloads from typing import overload, reveal_type @overload def f(x: int) -&gt; int: ... @overload def f(x: str) -&gt; str: ... def f(x: int | str) -&gt; int | str: return x reveal_type(f(0)) # revealed type: int reveal_type(f(&quot;&quot;)) # revealed type: str  ","version":"Next","tagName":"h3"},{"title":"Typing Features and PEPS available in each Python Version​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#typing-features-and-peps-available-in-each-python-version","content":" See the full list of features available in the Python type system here.  ","version":"Next","tagName":"h2"},{"title":"Key Highlights Summary:​","type":1,"pageTitle":"Typing for Python Developers","url":"/en/docs/typing-for-python-developers/#key-highlights-summary","content":" Inference: Python's static analyzers can infer types from your code, reducing the need for explicit annotations. This feature enhances code readability and helps catch bugs early.Defining Types: You can define types inline using Python's built-in types, which aids in documentation and improves IDE support.Advanced Types: The guide covers advanced concepts like composing types, using unions and optionals, generics, protocols, and structural types like dataclasses and TypedDict.Practical Examples: The guide includes examples of functions, generic classes, structural typing with protocols, and more, demonstrating how to apply these concepts in real-world scenarios. ","version":"Next","tagName":"h3"}]